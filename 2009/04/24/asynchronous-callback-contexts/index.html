<!DOCTYPE html>
<html>
<body>
	{ path: &#39;2009/04/24/asynchronous-callback-contexts/&#39;,
  __post: true,
  layout: &#39;post&#39;,
  title: &#39;Asynchronous Callback Contexts&#39;,
  _content: &#39;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.\n\n## The Problem\n\nEnd-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been &quot;cancelled&quot;. However, implementing this expected behavior takes some forethought.\n\nWhen asynchronous components raise events, these events are generally either queued to an &quot;originating&quot; thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.\n\n## The Solution\n\nThe answer is to define some sort of &quot;context&quot;. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component\&#39;s current context value. If they match, then the event knows it is safe to continue; if they don\&#39;t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.\n\nThe .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.\n\n## Callback Contexts in the Real World\n\nFire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named &quot;cookie&quot;. When the timer is enabled, it allocates a new object, saves it into &quot;cookie&quot;, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn\&#39;t proceed with the event if they don\&#39;t match.\n\nSystem.Timers.Timer does not change &quot;cookie&quot; when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.\n\n## Reusable CallbackContext Type\n\nOne of the new classes in version 1.2 of the [Nito Async](http://nitoasync.codeplex.com/) library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:\n\n- A delegate may be _bound_ to a CallbackContext. Binding a delegate results in a new delegate (the _bound delegate_) - which wraps the original delegate.\n- Every bound delegate is either _valid_ or _invalid_. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.\n\nDelegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.\n\nTo use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.\n\nThe only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in [Nito.Async](http://nitoasync.codeplex.com/) version 1.3.\n\n&#39;,
  source: &#39;_posts/2009-04-24-asynchronous-callback-contexts.md&#39;,
  raw: &#39;---\nlayout: post\ntitle: &quot;Asynchronous Callback Contexts&quot;\n---\nOne major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.\n\n## The Problem\n\nEnd-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been &quot;cancelled&quot;. However, implementing this expected behavior takes some forethought.\n\nWhen asynchronous components raise events, these events are generally either queued to an &quot;originating&quot; thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.\n\n## The Solution\n\nThe answer is to define some sort of &quot;context&quot;. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component\&#39;s current context value. If they match, then the event knows it is safe to continue; if they don\&#39;t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.\n\nThe .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.\n\n## Callback Contexts in the Real World\n\nFire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named &quot;cookie&quot;. When the timer is enabled, it allocates a new object, saves it into &quot;cookie&quot;, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn\&#39;t proceed with the event if they don\&#39;t match.\n\nSystem.Timers.Timer does not change &quot;cookie&quot; when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.\n\n## Reusable CallbackContext Type\n\nOne of the new classes in version 1.2 of the [Nito Async](http://nitoasync.codeplex.com/) library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:\n\n- A delegate may be _bound_ to a CallbackContext. Binding a delegate results in a new delegate (the _bound delegate_) - which wraps the original delegate.\n- Every bound delegate is either _valid_ or _invalid_. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.\n\nDelegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.\n\nTo use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.\n\nThe only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in [Nito.Async](http://nitoasync.codeplex.com/) version 1.3.\n\n&#39;,
  slug: &#39;asynchronous-callback-contexts&#39;,
  published: true,
  date: 
   { [Number: 1240545600000]
     _isAMomentObject: true,
     _i: Fri Apr 24 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
     _isUTC: false,
     _locale: 
      { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: [Function],
        _abbr: &#39;en&#39;,
        _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
     _d: Fri Apr 24 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
     _z: null,
     _pf: 
      { empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false },
     _isValid: true },
  updated: 
   { [Number: 1400776290662]
     _isAMomentObject: true,
     _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
     _isUTC: false,
     _locale: 
      { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: [Function],
        _abbr: &#39;en&#39;,
        _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
     _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
     _z: null },
  comments: true,
  photos: [],
  link: &#39;&#39;,
  _id: &#39;cie5tuln00001xorynzsev89f&#39;,
  content: &#39;&lt;p&gt;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.&lt;/p&gt;\n&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;End-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been “cancelled”. However, implementing this expected behavior takes some forethought.&lt;/p&gt;\n&lt;p&gt;When asynchronous components raise events, these events are generally either queued to an “originating” thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution&quot;&gt;The Solution&lt;/h2&gt;&lt;p&gt;The answer is to define some sort of “context”. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component’s current context value. If they match, then the event knows it is safe to continue; if they don’t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.&lt;/p&gt;\n&lt;p&gt;The .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.&lt;/p&gt;\n&lt;h2 id=&quot;Callback_Contexts_in_the_Real_World&quot;&gt;Callback Contexts in the Real World&lt;/h2&gt;&lt;p&gt;Fire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named “cookie”. When the timer is enabled, it allocates a new object, saves it into “cookie”, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn’t proceed with the event if they don’t match.&lt;/p&gt;\n&lt;p&gt;System.Timers.Timer does not change “cookie” when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.&lt;/p&gt;\n&lt;h2 id=&quot;Reusable_CallbackContext_Type&quot;&gt;Reusable CallbackContext Type&lt;/h2&gt;&lt;p&gt;One of the new classes in version 1.2 of the &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito Async&lt;/a&gt; library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;A delegate may be &lt;em&gt;bound&lt;/em&gt; to a CallbackContext. Binding a delegate results in a new delegate (the &lt;em&gt;bound delegate&lt;/em&gt;) - which wraps the original delegate.&lt;/li&gt;\n&lt;li&gt;Every bound delegate is either &lt;em&gt;valid&lt;/em&gt; or &lt;em&gt;invalid&lt;/em&gt;. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Delegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.&lt;/p&gt;\n&lt;p&gt;To use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.&lt;/p&gt;\n&lt;p&gt;The only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito.Async&lt;/a&gt; version 1.3.&lt;/p&gt;\n&#39;,
  excerpt: &#39;&#39;,
  more: &#39;&lt;p&gt;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.&lt;/p&gt;\n&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;End-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been “cancelled”. However, implementing this expected behavior takes some forethought.&lt;/p&gt;\n&lt;p&gt;When asynchronous components raise events, these events are generally either queued to an “originating” thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution&quot;&gt;The Solution&lt;/h2&gt;&lt;p&gt;The answer is to define some sort of “context”. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component’s current context value. If they match, then the event knows it is safe to continue; if they don’t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.&lt;/p&gt;\n&lt;p&gt;The .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.&lt;/p&gt;\n&lt;h2 id=&quot;Callback_Contexts_in_the_Real_World&quot;&gt;Callback Contexts in the Real World&lt;/h2&gt;&lt;p&gt;Fire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named “cookie”. When the timer is enabled, it allocates a new object, saves it into “cookie”, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn’t proceed with the event if they don’t match.&lt;/p&gt;\n&lt;p&gt;System.Timers.Timer does not change “cookie” when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.&lt;/p&gt;\n&lt;h2 id=&quot;Reusable_CallbackContext_Type&quot;&gt;Reusable CallbackContext Type&lt;/h2&gt;&lt;p&gt;One of the new classes in version 1.2 of the &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito Async&lt;/a&gt; library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;A delegate may be &lt;em&gt;bound&lt;/em&gt; to a CallbackContext. Binding a delegate results in a new delegate (the &lt;em&gt;bound delegate&lt;/em&gt;) - which wraps the original delegate.&lt;/li&gt;\n&lt;li&gt;Every bound delegate is either &lt;em&gt;valid&lt;/em&gt; or &lt;em&gt;invalid&lt;/em&gt;. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Delegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.&lt;/p&gt;\n&lt;p&gt;To use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.&lt;/p&gt;\n&lt;p&gt;The only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito.Async&lt;/a&gt; version 1.3.&lt;/p&gt;\n&#39;,
  permalink: &#39;http://yoursite.com/2009/04/24/asynchronous-callback-contexts/&#39;,
  full_source: &#39;C:\\Work\\blog\\source\\_posts\\2009-04-24-asynchronous-callback-contexts.md&#39;,
  asset_dir: &#39;C:\\Work\\blog\\source\\_posts\\2009-04-24-asynchronous-callback-contexts\\&#39;,
  tags: { data: [], length: 0 },
  categories: { data: [], length: 0 },
  prev: 
   { layout: &#39;post&#39;,
     title: &#39;Sample code: Length-prefix message framing for streams&#39;,
     series: &#39;TCP/IP .NET Sockets FAQ&#39;,
     seriesTitle: &#39;Length-Prefix Example&#39;,
     _content: &#39;The necessity of message framing is discussed at [http://blog.stephencleary.com/2009/04/message-framing.html]({% post_url 2009-04-30-message-framing %}).\n\nThe class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the [Nito.Async](http://www.codeplex.com/NitoAsync) library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.\n\nNote that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.\n\n```cs\n// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html\n/// &lt;summary&gt;\n/// Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// &lt;para&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;see cref=&quot;MessageArrived&quot;/&gt;. As bytes arrive at the stream, pass them to &lt;see cref=&quot;DataReceived&quot;/&gt;, which will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.&lt;/para&gt;\n/// &lt;para&gt;If &lt;see cref=&quot;DataReceived&quot;/&gt; raises &lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance.&lt;/para&gt;\n/// &lt;para&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;/para&gt;\n/// &lt;para&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;/para&gt;\n/// &lt;/remarks&gt;\npublic class PacketProtocol\n{\n    /// &lt;summary&gt;\n    /// Wraps a message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;message&quot;&gt;The message to send.&lt;/param&gt;\n    public static byte[] WrapMessage(byte[] message)\n    {\n        // Get the length prefix for the message\n        byte[] lengthPrefix = BitConverter.GetBytes(message.Length);\n  \n        // Concatenate the length prefix and the message\n        byte[] ret = new byte[lengthPrefix.Length + message.Length];\n        lengthPrefix.CopyTo(ret, 0);\n        message.CopyTo(ret, lengthPrefix.Length);\n  \n        return ret;\n    }\n  \n    /// &lt;summary&gt;\n    /// Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    public static byte[] WrapKeepaliveMessage()\n    {\n        return BitConverter.GetBytes((int)0);\n    }\n  \n    /// &lt;summary&gt;\n    /// Initializes a new &lt;see cref=&quot;PacketProtocol&quot;/&gt;, limiting message sizes to the given maximum size.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;maxMessageSize&quot;&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;/param&gt;\n    public PacketProtocol(int maxMessageSize)\n    {\n        // We allocate the buffer for receiving message lengths immediately\n        this.lengthBuffer = new byte[sizeof(int)];\n        this.maxMessageSize = maxMessageSize;\n    }\n  \n    /// &lt;summary&gt;\n    /// The buffer for the length prefix; this is always 4 bytes long.\n    /// &lt;/summary&gt;\n    private byte[] lengthBuffer;\n  \n    /// &lt;summary&gt;\n    /// The buffer for the data; this is null if we are receiving the length prefix buffer.\n    /// &lt;/summary&gt;\n    private byte[] dataBuffer;\n  \n    /// &lt;summary&gt;\n    /// The number of bytes already read into the buffer (the length buffer if &lt;see cref=&quot;dataBuffer&quot;/&gt; is null, otherwise the data buffer).\n    /// &lt;/summary&gt;\n    private int bytesReceived;\n  \n    /// &lt;summary&gt;\n    /// The maximum size of messages allowed.\n    /// &lt;/summary&gt;\n    private int maxMessageSize;\n  \n    /// &lt;summary&gt;\n    /// Indicates the completion of a message read from the stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;/para&gt;\n    /// &lt;para&gt;This event is invoked from within a call to &lt;see cref=&quot;DataReceived&quot;/&gt;. Handlers for this event should not call &lt;see cref=&quot;DataReceived&quot;/&gt;.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    public Action&lt;byte[]&gt; MessageArrived { get; set; }\n  \n    /// &lt;summary&gt;\n    /// Notifies the &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance that incoming data has been received from the stream. This method will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This method may invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; zero or more times.&lt;/para&gt;\n    /// &lt;para&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;see cref=&quot;PacketProtocol&quot;/&gt; takes no action in this case.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;data&quot;&gt;The data received from the stream. Cannot be null.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    public void DataReceived(byte[] data)\n    {\n        // Process the incoming data in chunks, as the ReadCompleted requests it\n  \n        // Logically, we are satisfying read requests with the received data, instead of processing the\n        //  incoming buffer looking for messages.\n  \n        int i = 0;\n        while (i != data.Length)\n        {\n            // Determine how many bytes we want to transfer to the buffer and transfer them\n            int bytesAvailable = data.Length - i;\n            if (this.dataBuffer != null)\n            {\n                // We\&#39;re reading into the data buffer\n                int bytesRequested = this.dataBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.dataBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n            else\n            {\n                // We\&#39;re reading into the length prefix buffer\n                int bytesRequested = this.lengthBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.lengthBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n        }\n    }\n  \n    /// &lt;summary&gt;\n    /// Called when a read completes. Parses the received data and calls &lt;see cref=&quot;MessageArrived&quot;/&gt; if necessary.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;count&quot;&gt;The number of bytes read.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    private void ReadCompleted(int count)\n    {\n        // Get the number of bytes read into the buffer\n        this.bytesReceived += count;\n  \n        if (this.dataBuffer == null)\n        {\n            // We\&#39;re currently receiving the length buffer\n  \n            if (this.bytesReceived != sizeof(int))\n            {\n                // We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten the length buffer\n                int length = BitConverter.ToInt32(this.lengthBuffer, 0);\n  \n                // Sanity check for length &lt; 0\n                if (length &lt; 0)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length is less than zero&quot;);\n  \n                // Another sanity check is needed here for very large packets, to prevent denial-of-service attacks\n                if (this.maxMessageSize &gt; 0 &amp;&amp; length &gt; this.maxMessageSize)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length &quot; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &quot; is larger than maximum message size &quot; + this.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));\n  \n                // Zero-length packets are allowed as keepalives\n                if (length == 0)\n                {\n                    this.bytesReceived = 0;\n                    if (this.MessageArrived != null)\n                        this.MessageArrived(new byte[0]);\n                }\n                else\n                {\n                    // Create the data buffer and start reading into it\n                    this.dataBuffer = new byte[length];\n                    this.bytesReceived = 0;\n                }\n            }\n        }\n        else\n        {\n            if (this.bytesReceived != this.dataBuffer.Length)\n            {\n                // We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten an entire packet\n                if (this.MessageArrived != null)\n                    this.MessageArrived(this.dataBuffer);\n  \n                // Start reading the length buffer again\n                this.dataBuffer = null;\n                this.bytesReceived = 0;\n            }\n        }\n    }\n}\n```\n&#39;,
     source: &#39;_posts/2009-04-30-sample-code-length-prefix-message.md&#39;,
     raw: &#39;---\nlayout: post\ntitle: &quot;Sample code: Length-prefix message framing for streams&quot;\nseries: &quot;TCP/IP .NET Sockets FAQ&quot;\nseriesTitle: &quot;Length-Prefix Example&quot;\n---\nThe necessity of message framing is discussed at [http://blog.stephencleary.com/2009/04/message-framing.html]({% post_url 2009-04-30-message-framing %}).\n\nThe class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the [Nito.Async](http://www.codeplex.com/NitoAsync) library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.\n\nNote that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.\n\n```cs\n// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html\n/// &lt;summary&gt;\n/// Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// &lt;para&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;see cref=&quot;MessageArrived&quot;/&gt;. As bytes arrive at the stream, pass them to &lt;see cref=&quot;DataReceived&quot;/&gt;, which will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.&lt;/para&gt;\n/// &lt;para&gt;If &lt;see cref=&quot;DataReceived&quot;/&gt; raises &lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance.&lt;/para&gt;\n/// &lt;para&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;/para&gt;\n/// &lt;para&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;/para&gt;\n/// &lt;/remarks&gt;\npublic class PacketProtocol\n{\n    /// &lt;summary&gt;\n    /// Wraps a message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;message&quot;&gt;The message to send.&lt;/param&gt;\n    public static byte[] WrapMessage(byte[] message)\n    {\n        // Get the length prefix for the message\n        byte[] lengthPrefix = BitConverter.GetBytes(message.Length);\n  \n        // Concatenate the length prefix and the message\n        byte[] ret = new byte[lengthPrefix.Length + message.Length];\n        lengthPrefix.CopyTo(ret, 0);\n        message.CopyTo(ret, lengthPrefix.Length);\n  \n        return ret;\n    }\n  \n    /// &lt;summary&gt;\n    /// Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    public static byte[] WrapKeepaliveMessage()\n    {\n        return BitConverter.GetBytes((int)0);\n    }\n  \n    /// &lt;summary&gt;\n    /// Initializes a new &lt;see cref=&quot;PacketProtocol&quot;/&gt;, limiting message sizes to the given maximum size.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;maxMessageSize&quot;&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;/param&gt;\n    public PacketProtocol(int maxMessageSize)\n    {\n        // We allocate the buffer for receiving message lengths immediately\n        this.lengthBuffer = new byte[sizeof(int)];\n        this.maxMessageSize = maxMessageSize;\n    }\n  \n    /// &lt;summary&gt;\n    /// The buffer for the length prefix; this is always 4 bytes long.\n    /// &lt;/summary&gt;\n    private byte[] lengthBuffer;\n  \n    /// &lt;summary&gt;\n    /// The buffer for the data; this is null if we are receiving the length prefix buffer.\n    /// &lt;/summary&gt;\n    private byte[] dataBuffer;\n  \n    /// &lt;summary&gt;\n    /// The number of bytes already read into the buffer (the length buffer if &lt;see cref=&quot;dataBuffer&quot;/&gt; is null, otherwise the data buffer).\n    /// &lt;/summary&gt;\n    private int bytesReceived;\n  \n    /// &lt;summary&gt;\n    /// The maximum size of messages allowed.\n    /// &lt;/summary&gt;\n    private int maxMessageSize;\n  \n    /// &lt;summary&gt;\n    /// Indicates the completion of a message read from the stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;/para&gt;\n    /// &lt;para&gt;This event is invoked from within a call to &lt;see cref=&quot;DataReceived&quot;/&gt;. Handlers for this event should not call &lt;see cref=&quot;DataReceived&quot;/&gt;.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    public Action&lt;byte[]&gt; MessageArrived { get; set; }\n  \n    /// &lt;summary&gt;\n    /// Notifies the &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance that incoming data has been received from the stream. This method will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This method may invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; zero or more times.&lt;/para&gt;\n    /// &lt;para&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;see cref=&quot;PacketProtocol&quot;/&gt; takes no action in this case.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;data&quot;&gt;The data received from the stream. Cannot be null.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    public void DataReceived(byte[] data)\n    {\n        // Process the incoming data in chunks, as the ReadCompleted requests it\n  \n        // Logically, we are satisfying read requests with the received data, instead of processing the\n        //  incoming buffer looking for messages.\n  \n        int i = 0;\n        while (i != data.Length)\n        {\n            // Determine how many bytes we want to transfer to the buffer and transfer them\n            int bytesAvailable = data.Length - i;\n            if (this.dataBuffer != null)\n            {\n                // We\&#39;re reading into the data buffer\n                int bytesRequested = this.dataBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.dataBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n            else\n            {\n                // We\&#39;re reading into the length prefix buffer\n                int bytesRequested = this.lengthBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.lengthBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n        }\n    }\n  \n    /// &lt;summary&gt;\n    /// Called when a read completes. Parses the received data and calls &lt;see cref=&quot;MessageArrived&quot;/&gt; if necessary.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;count&quot;&gt;The number of bytes read.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    private void ReadCompleted(int count)\n    {\n        // Get the number of bytes read into the buffer\n        this.bytesReceived += count;\n  \n        if (this.dataBuffer == null)\n        {\n            // We\&#39;re currently receiving the length buffer\n  \n            if (this.bytesReceived != sizeof(int))\n            {\n                // We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten the length buffer\n                int length = BitConverter.ToInt32(this.lengthBuffer, 0);\n  \n                // Sanity check for length &lt; 0\n                if (length &lt; 0)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length is less than zero&quot;);\n  \n                // Another sanity check is needed here for very large packets, to prevent denial-of-service attacks\n                if (this.maxMessageSize &gt; 0 &amp;&amp; length &gt; this.maxMessageSize)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length &quot; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &quot; is larger than maximum message size &quot; + this.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));\n  \n                // Zero-length packets are allowed as keepalives\n                if (length == 0)\n                {\n                    this.bytesReceived = 0;\n                    if (this.MessageArrived != null)\n                        this.MessageArrived(new byte[0]);\n                }\n                else\n                {\n                    // Create the data buffer and start reading into it\n                    this.dataBuffer = new byte[length];\n                    this.bytesReceived = 0;\n                }\n            }\n        }\n        else\n        {\n            if (this.bytesReceived != this.dataBuffer.Length)\n            {\n                // We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten an entire packet\n                if (this.MessageArrived != null)\n                    this.MessageArrived(this.dataBuffer);\n  \n                // Start reading the length buffer again\n                this.dataBuffer = null;\n                this.bytesReceived = 0;\n            }\n        }\n    }\n}\n```\n&#39;,
     slug: &#39;sample-code-length-prefix-message&#39;,
     published: true,
     date: 
      { [Number: 1241064000000]
        _isAMomentObject: true,
        _i: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
        _isUTC: false,
        _locale: 
         { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
           ordinal: [Function],
           _abbr: &#39;en&#39;,
           _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
        _d: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
        _z: null,
        _pf: 
         { empty: false,
           unusedTokens: [],
           unusedInput: [],
           overflow: -2,
           charsLeftOver: 0,
           nullInput: false,
           invalidMonth: null,
           invalidFormat: false,
           userInvalidated: false,
           iso: false },
        _isValid: true },
     updated: 
      { [Number: 1441382486515]
        _isAMomentObject: true,
        _i: Fri Sep 04 2015 12:01:26 GMT-0400 (Eastern Daylight Time),
        _isUTC: false,
        _locale: 
         { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
           ordinal: [Function],
           _abbr: &#39;en&#39;,
           _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
        _d: Fri Sep 04 2015 12:01:26 GMT-0400 (Eastern Daylight Time),
        _z: null },
     _id: &#39;cie5tuln80004xorympah9d37&#39;,
     comments: true,
     photos: [],
     link: &#39;&#39;,
     content: &#39;&lt;p&gt;The necessity of message framing is discussed at &lt;a href=&quot;!--￼1--&quot;&gt;http://blog.stephencleary.com/2009/04/message-framing.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.&lt;/p&gt;\n&lt;p&gt;Note that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.&lt;/p&gt;\n&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;182&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;183&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;184&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;185&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;186&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;187&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;188&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;189&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;190&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;191&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;193&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;195&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt;. As bytes arrive at the stream, pass them to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;, which will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;If &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt; raises &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&amp;gt;&lt;/span&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;The message to send.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapMessage(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the length prefix for the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthPrefix = BitConverter.GetBytes(message.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Concatenate the length prefix and the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[lengthPrefix.Length + message.Length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lengthPrefix.CopyTo(ret, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message.CopyTo(ret, lengthPrefix.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapKeepaliveMessage()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; BitConverter.GetBytes((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Initializes a new &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt;, limiting message sizes to the given maximum size.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;maxMessageSize&quot;&amp;gt;&lt;/span&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// We allocate the buffer for receiving message lengths immediately&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize = maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the length prefix; this is always 4 bytes long.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the data; this is null if we are receiving the length prefix buffer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] dataBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The number of bytes already read into the buffer (the length buffer if &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;dataBuffer&quot;/&amp;gt;&lt;/span&gt; is null, otherwise the data buffer).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The maximum size of messages allowed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Indicates the completion of a message read from the stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This event is invoked from within a call to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;. Handlers for this event should not call &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Action&amp;lt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; MessageArrived &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Notifies the &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance that incoming data has been received from the stream. This method will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This method may invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; zero or more times.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; takes no action in this case.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&lt;/span&gt;The data received from the stream. Cannot be null.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataReceived&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] data&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process the incoming data in chunks, as the ReadCompleted requests it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Logically, we are satisfying read requests with the received data, instead of processing the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//  incoming buffer looking for messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i != data.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Determine how many bytes we want to transfer to the buffer and transfer them&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesAvailable = data.Length - i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the data buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the length prefix buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Called when a read completes. Parses the received data and calls &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; if necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&lt;/span&gt;The number of bytes read.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReadCompleted&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the number of bytes read into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived += count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// We\&#39;re currently receiving the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length = BitConverter.ToInt32(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Sanity check for length &amp;lt; 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length is less than zero&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Another sanity check is needed here for very large packets, to prevent denial-of-service attacks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; length &amp;gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length &quot;&lt;/span&gt; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &lt;span class=&quot;string&quot;&gt;&quot; is larger than maximum message size &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Zero-length packets are allowed as keepalives&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Create the data buffer and start reading into it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten an entire packet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Start reading the length buffer again&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;\n&#39;,
     excerpt: &#39;&#39;,
     more: &#39;&lt;p&gt;The necessity of message framing is discussed at &lt;a href=&quot;!--￼1--&quot;&gt;http://blog.stephencleary.com/2009/04/message-framing.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.&lt;/p&gt;\n&lt;p&gt;Note that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.&lt;/p&gt;\n&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;182&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;183&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;184&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;185&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;186&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;187&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;188&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;189&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;190&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;191&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;193&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;195&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt;. As bytes arrive at the stream, pass them to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;, which will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;If &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt; raises &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&amp;gt;&lt;/span&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;The message to send.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapMessage(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the length prefix for the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthPrefix = BitConverter.GetBytes(message.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Concatenate the length prefix and the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[lengthPrefix.Length + message.Length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lengthPrefix.CopyTo(ret, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message.CopyTo(ret, lengthPrefix.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapKeepaliveMessage()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; BitConverter.GetBytes((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Initializes a new &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt;, limiting message sizes to the given maximum size.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;maxMessageSize&quot;&amp;gt;&lt;/span&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// We allocate the buffer for receiving message lengths immediately&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize = maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the length prefix; this is always 4 bytes long.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the data; this is null if we are receiving the length prefix buffer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] dataBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The number of bytes already read into the buffer (the length buffer if &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;dataBuffer&quot;/&amp;gt;&lt;/span&gt; is null, otherwise the data buffer).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The maximum size of messages allowed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Indicates the completion of a message read from the stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This event is invoked from within a call to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;. Handlers for this event should not call &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Action&amp;lt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; MessageArrived &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Notifies the &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance that incoming data has been received from the stream. This method will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This method may invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; zero or more times.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; takes no action in this case.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&lt;/span&gt;The data received from the stream. Cannot be null.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataReceived&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] data&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process the incoming data in chunks, as the ReadCompleted requests it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Logically, we are satisfying read requests with the received data, instead of processing the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//  incoming buffer looking for messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i != data.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Determine how many bytes we want to transfer to the buffer and transfer them&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesAvailable = data.Length - i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the data buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the length prefix buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Called when a read completes. Parses the received data and calls &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; if necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&lt;/span&gt;The number of bytes read.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReadCompleted&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the number of bytes read into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived += count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// We\&#39;re currently receiving the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length = BitConverter.ToInt32(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Sanity check for length &amp;lt; 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length is less than zero&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Another sanity check is needed here for very large packets, to prevent denial-of-service attacks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; length &amp;gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length &quot;&lt;/span&gt; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &lt;span class=&quot;string&quot;&gt;&quot; is larger than maximum message size &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Zero-length packets are allowed as keepalives&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Create the data buffer and start reading into it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten an entire packet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Start reading the length buffer again&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;\n&#39;,
     path: [Getter],
     permalink: [Getter],
     full_source: [Getter],
     asset_dir: [Getter],
     tags: [Getter],
     categories: [Getter],
     prev: 
      { layout: &#39;post&#39;,
        title: &#39;Message Framing&#39;,
        series: &#39;TCP/IP .NET Sockets FAQ&#39;,
        seriesTitle: &#39;Message Framing&#39;,
        _content: &#39;## The Problem\n\nOne of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single &quot;Send&quot; will result in a single &quot;Receive&quot;.\n\nSome TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single &quot;Send&quot; does _not_ send a single _packet_.\n\nLocal machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single &quot;sends&quot; do in fact correspond to  single &quot;receives&quot;. Unfortunately, this is only a coincidence.\n\nThis problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!\n\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;\n&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;\n\nTrue story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to &quot;that buggy Windows OS&quot; or &quot;another network glitch&quot; and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.\n&lt;/div&gt;\n\n## The Solution, Part 1 - Understanding\n\nFirst, one must understand the abstraction of TCP/IP. From the application\&#39;s perspective, TCP operates on _streams_ of data, _never packets_. Repeat this mantra three times: &quot;TCP does not operate on _packets_ of data. TCP operates on _streams_ of data.&quot;\n\nThere is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a &quot;receive&quot; method, and one may write to the outgoing stream by calling a &quot;send&quot; method. If one side calls &quot;send&quot; to send 5 bytes, and then calls &quot;send&quot; to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling &quot;receive&quot; 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to &quot;receive&quot;.\n\nSending data to the TCP stream is rather easy; all one has to do is call &quot;send&quot;, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the &quot;receive N bytes&quot; operation will wait until _at least_ one byte and _at most_ N bytes arrive on the incoming stream before it returns. Note that the &quot;receive N bytes&quot; operation will complete even if it doesn\&#39;t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.\n\nTo repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of &quot;messages&quot;; for example, a client may send a &quot;Lookup X&quot; message to the server, and the server will respond with an &quot;X Data&quot; or &quot;X Not Found&quot; message. Since TCP operates on streams, one must design a &quot;message framing&quot; protocol that will wrap the messages sent back and forth.\n\n## The Solution, Part 2 - Design\n\nThere are two approaches commonly used for message framing: length prefixing and delimiters.\n\n**Length prefixing** prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; &quot;4-byte signed little-endian&quot; (i.e., &quot;int&quot; in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.\n\nReceiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using &quot;4-byte signed little-endian&quot;, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.\n\n**Delimiters** are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.\n\n## A Brief Security Note\n\nWhether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size &quot;sanity check&quot; in the socket reading code.\n\n## The Solution, Part 3 - Code\n\nA code sample for using length-prefixing is in its own blog post at [http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html]({% post_url 2009-04-30-sample-code-length-prefix-message %}).\n\nAnother decent code example of length prefixing is on [Jon Cole\&#39;s blog](http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx), although he assumes all the messages are just ASCII strings.\n\nYet another example of length prefixing is in the [Nito.Async](http://www.codeplex.com/NitoAsync) library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.\n\n&#39;,
        source: &#39;_posts/2009-04-30-message-framing.md&#39;,
        raw: &#39;---\nlayout: post\ntitle: &quot;Message Framing&quot;\nseries: &quot;TCP/IP .NET Sockets FAQ&quot;\nseriesTitle: &quot;Message Framing&quot;\n---\n## The Problem\n\nOne of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single &quot;Send&quot; will result in a single &quot;Receive&quot;.\n\nSome TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single &quot;Send&quot; does _not_ send a single _packet_.\n\nLocal machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single &quot;sends&quot; do in fact correspond to  single &quot;receives&quot;. Unfortunately, this is only a coincidence.\n\nThis problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!\n\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;\n&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;\n\nTrue story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to &quot;that buggy Windows OS&quot; or &quot;another network glitch&quot; and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.\n&lt;/div&gt;\n\n## The Solution, Part 1 - Understanding\n\nFirst, one must understand the abstraction of TCP/IP. From the application\&#39;s perspective, TCP operates on _streams_ of data, _never packets_. Repeat this mantra three times: &quot;TCP does not operate on _packets_ of data. TCP operates on _streams_ of data.&quot;\n\nThere is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a &quot;receive&quot; method, and one may write to the outgoing stream by calling a &quot;send&quot; method. If one side calls &quot;send&quot; to send 5 bytes, and then calls &quot;send&quot; to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling &quot;receive&quot; 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to &quot;receive&quot;.\n\nSending data to the TCP stream is rather easy; all one has to do is call &quot;send&quot;, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the &quot;receive N bytes&quot; operation will wait until _at least_ one byte and _at most_ N bytes arrive on the incoming stream before it returns. Note that the &quot;receive N bytes&quot; operation will complete even if it doesn\&#39;t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.\n\nTo repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of &quot;messages&quot;; for example, a client may send a &quot;Lookup X&quot; message to the server, and the server will respond with an &quot;X Data&quot; or &quot;X Not Found&quot; message. Since TCP operates on streams, one must design a &quot;message framing&quot; protocol that will wrap the messages sent back and forth.\n\n## The Solution, Part 2 - Design\n\nThere are two approaches commonly used for message framing: length prefixing and delimiters.\n\n**Length prefixing** prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; &quot;4-byte signed little-endian&quot; (i.e., &quot;int&quot; in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.\n\nReceiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using &quot;4-byte signed little-endian&quot;, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.\n\n**Delimiters** are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.\n\n## A Brief Security Note\n\nWhether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size &quot;sanity check&quot; in the socket reading code.\n\n## The Solution, Part 3 - Code\n\nA code sample for using length-prefixing is in its own blog post at [http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html]({% post_url 2009-04-30-sample-code-length-prefix-message %}).\n\nAnother decent code example of length prefixing is on [Jon Cole\&#39;s blog](http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx), although he assumes all the messages are just ASCII strings.\n\nYet another example of length prefixing is in the [Nito.Async](http://www.codeplex.com/NitoAsync) library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.\n\n&#39;,
        slug: &#39;message-framing&#39;,
        published: true,
        date: 
         { [Number: 1241064000000]
           _isAMomentObject: true,
           _i: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
           _z: null,
           _pf: 
            { empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false },
           _isValid: true },
        updated: 
         { [Number: 1400778787476]
           _isAMomentObject: true,
           _i: Thu May 22 2014 13:13:07 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Thu May 22 2014 13:13:07 GMT-0400 (Eastern Daylight Time),
           _z: null },
        comments: true,
        photos: [],
        link: &#39;&#39;,
        _id: &#39;cie5tulna0005xoryq80g0aac&#39;,
        content: &#39;&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;One of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single “Send” will result in a single “Receive”.&lt;/p&gt;\n&lt;p&gt;Some TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single “Send” does &lt;em&gt;not&lt;/em&gt; send a single &lt;em&gt;packet&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Local machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single “sends” do in fact correspond to  single “receives”. Unfortunately, this is only a coincidence.&lt;/p&gt;\n&lt;p&gt;This problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!&lt;/p&gt;\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;&lt;br&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;True story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to “that buggy Windows OS” or “another network glitch” and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.&lt;br&gt;&lt;/div&gt;\n\n&lt;h2 id=&quot;The_Solution,_Part_1_-_Understanding&quot;&gt;The Solution, Part 1 - Understanding&lt;/h2&gt;&lt;p&gt;First, one must understand the abstraction of TCP/IP. From the application’s perspective, TCP operates on &lt;em&gt;streams&lt;/em&gt; of data, &lt;em&gt;never packets&lt;/em&gt;. Repeat this mantra three times: “TCP does not operate on &lt;em&gt;packets&lt;/em&gt; of data. TCP operates on &lt;em&gt;streams&lt;/em&gt; of data.”&lt;/p&gt;\n&lt;p&gt;There is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a “receive” method, and one may write to the outgoing stream by calling a “send” method. If one side calls “send” to send 5 bytes, and then calls “send” to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling “receive” 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to “receive”.&lt;/p&gt;\n&lt;p&gt;Sending data to the TCP stream is rather easy; all one has to do is call “send”, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the “receive N bytes” operation will wait until &lt;em&gt;at least&lt;/em&gt; one byte and &lt;em&gt;at most&lt;/em&gt; N bytes arrive on the incoming stream before it returns. Note that the “receive N bytes” operation will complete even if it doesn’t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.&lt;/p&gt;\n&lt;p&gt;To repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of “messages”; for example, a client may send a “Lookup X” message to the server, and the server will respond with an “X Data” or “X Not Found” message. Since TCP operates on streams, one must design a “message framing” protocol that will wrap the messages sent back and forth.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_2_-_Design&quot;&gt;The Solution, Part 2 - Design&lt;/h2&gt;&lt;p&gt;There are two approaches commonly used for message framing: length prefixing and delimiters.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Length prefixing&lt;/strong&gt; prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; “4-byte signed little-endian” (i.e., “int” in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.&lt;/p&gt;\n&lt;p&gt;Receiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using “4-byte signed little-endian”, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Delimiters&lt;/strong&gt; are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.&lt;/p&gt;\n&lt;h2 id=&quot;A_Brief_Security_Note&quot;&gt;A Brief Security Note&lt;/h2&gt;&lt;p&gt;Whether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size “sanity check” in the socket reading code.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_3_-_Code&quot;&gt;The Solution, Part 3 - Code&lt;/h2&gt;&lt;p&gt;A code sample for using length-prefixing is in its own blog post at &lt;a href=&quot;!--￼0--&quot;&gt;http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Another decent code example of length prefixing is on &lt;a href=&quot;http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx&quot;&gt;Jon Cole’s blog&lt;/a&gt;, although he assumes all the messages are just ASCII strings.&lt;/p&gt;\n&lt;p&gt;Yet another example of length prefixing is in the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.&lt;/p&gt;\n&#39;,
        excerpt: &#39;&#39;,
        more: &#39;&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;One of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single “Send” will result in a single “Receive”.&lt;/p&gt;\n&lt;p&gt;Some TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single “Send” does &lt;em&gt;not&lt;/em&gt; send a single &lt;em&gt;packet&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Local machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single “sends” do in fact correspond to  single “receives”. Unfortunately, this is only a coincidence.&lt;/p&gt;\n&lt;p&gt;This problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!&lt;/p&gt;\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;&lt;br&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;True story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to “that buggy Windows OS” or “another network glitch” and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.&lt;br&gt;&lt;/div&gt;\n\n&lt;h2 id=&quot;The_Solution,_Part_1_-_Understanding&quot;&gt;The Solution, Part 1 - Understanding&lt;/h2&gt;&lt;p&gt;First, one must understand the abstraction of TCP/IP. From the application’s perspective, TCP operates on &lt;em&gt;streams&lt;/em&gt; of data, &lt;em&gt;never packets&lt;/em&gt;. Repeat this mantra three times: “TCP does not operate on &lt;em&gt;packets&lt;/em&gt; of data. TCP operates on &lt;em&gt;streams&lt;/em&gt; of data.”&lt;/p&gt;\n&lt;p&gt;There is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a “receive” method, and one may write to the outgoing stream by calling a “send” method. If one side calls “send” to send 5 bytes, and then calls “send” to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling “receive” 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to “receive”.&lt;/p&gt;\n&lt;p&gt;Sending data to the TCP stream is rather easy; all one has to do is call “send”, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the “receive N bytes” operation will wait until &lt;em&gt;at least&lt;/em&gt; one byte and &lt;em&gt;at most&lt;/em&gt; N bytes arrive on the incoming stream before it returns. Note that the “receive N bytes” operation will complete even if it doesn’t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.&lt;/p&gt;\n&lt;p&gt;To repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of “messages”; for example, a client may send a “Lookup X” message to the server, and the server will respond with an “X Data” or “X Not Found” message. Since TCP operates on streams, one must design a “message framing” protocol that will wrap the messages sent back and forth.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_2_-_Design&quot;&gt;The Solution, Part 2 - Design&lt;/h2&gt;&lt;p&gt;There are two approaches commonly used for message framing: length prefixing and delimiters.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Length prefixing&lt;/strong&gt; prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; “4-byte signed little-endian” (i.e., “int” in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.&lt;/p&gt;\n&lt;p&gt;Receiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using “4-byte signed little-endian”, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Delimiters&lt;/strong&gt; are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.&lt;/p&gt;\n&lt;h2 id=&quot;A_Brief_Security_Note&quot;&gt;A Brief Security Note&lt;/h2&gt;&lt;p&gt;Whether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size “sanity check” in the socket reading code.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_3_-_Code&quot;&gt;The Solution, Part 3 - Code&lt;/h2&gt;&lt;p&gt;A code sample for using length-prefixing is in its own blog post at &lt;a href=&quot;!--￼0--&quot;&gt;http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Another decent code example of length prefixing is on &lt;a href=&quot;http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx&quot;&gt;Jon Cole’s blog&lt;/a&gt;, although he assumes all the messages are just ASCII strings.&lt;/p&gt;\n&lt;p&gt;Yet another example of length prefixing is in the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.&lt;/p&gt;\n&#39;,
        path: [Getter],
        permalink: [Getter],
        full_source: [Getter],
        asset_dir: [Getter],
        tags: [Getter],
        categories: [Getter],
        next: [Circular] },
     next: 
      { layout: &#39;post&#39;,
        title: &#39;Asynchronous Callback Contexts&#39;,
        _content: &#39;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.\n\n## The Problem\n\nEnd-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been &quot;cancelled&quot;. However, implementing this expected behavior takes some forethought.\n\nWhen asynchronous components raise events, these events are generally either queued to an &quot;originating&quot; thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.\n\n## The Solution\n\nThe answer is to define some sort of &quot;context&quot;. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component\&#39;s current context value. If they match, then the event knows it is safe to continue; if they don\&#39;t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.\n\nThe .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.\n\n## Callback Contexts in the Real World\n\nFire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named &quot;cookie&quot;. When the timer is enabled, it allocates a new object, saves it into &quot;cookie&quot;, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn\&#39;t proceed with the event if they don\&#39;t match.\n\nSystem.Timers.Timer does not change &quot;cookie&quot; when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.\n\n## Reusable CallbackContext Type\n\nOne of the new classes in version 1.2 of the [Nito Async](http://nitoasync.codeplex.com/) library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:\n\n- A delegate may be _bound_ to a CallbackContext. Binding a delegate results in a new delegate (the _bound delegate_) - which wraps the original delegate.\n- Every bound delegate is either _valid_ or _invalid_. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.\n\nDelegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.\n\nTo use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.\n\nThe only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in [Nito.Async](http://nitoasync.codeplex.com/) version 1.3.\n\n&#39;,
        source: &#39;_posts/2009-04-24-asynchronous-callback-contexts.md&#39;,
        raw: &#39;---\nlayout: post\ntitle: &quot;Asynchronous Callback Contexts&quot;\n---\nOne major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.\n\n## The Problem\n\nEnd-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been &quot;cancelled&quot;. However, implementing this expected behavior takes some forethought.\n\nWhen asynchronous components raise events, these events are generally either queued to an &quot;originating&quot; thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.\n\n## The Solution\n\nThe answer is to define some sort of &quot;context&quot;. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component\&#39;s current context value. If they match, then the event knows it is safe to continue; if they don\&#39;t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.\n\nThe .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.\n\n## Callback Contexts in the Real World\n\nFire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named &quot;cookie&quot;. When the timer is enabled, it allocates a new object, saves it into &quot;cookie&quot;, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn\&#39;t proceed with the event if they don\&#39;t match.\n\nSystem.Timers.Timer does not change &quot;cookie&quot; when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.\n\n## Reusable CallbackContext Type\n\nOne of the new classes in version 1.2 of the [Nito Async](http://nitoasync.codeplex.com/) library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:\n\n- A delegate may be _bound_ to a CallbackContext. Binding a delegate results in a new delegate (the _bound delegate_) - which wraps the original delegate.\n- Every bound delegate is either _valid_ or _invalid_. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.\n\nDelegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.\n\nTo use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.\n\nThe only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in [Nito.Async](http://nitoasync.codeplex.com/) version 1.3.\n\n&#39;,
        slug: &#39;asynchronous-callback-contexts&#39;,
        published: true,
        date: 
         { [Number: 1240545600000]
           _isAMomentObject: true,
           _i: Fri Apr 24 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Fri Apr 24 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
           _z: null,
           _pf: 
            { empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false },
           _isValid: true },
        updated: 
         { [Number: 1400776290662]
           _isAMomentObject: true,
           _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
           _z: null },
        comments: true,
        photos: [],
        link: &#39;&#39;,
        _id: &#39;cie5tuln00001xorynzsev89f&#39;,
        content: &#39;&lt;p&gt;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.&lt;/p&gt;\n&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;End-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been “cancelled”. However, implementing this expected behavior takes some forethought.&lt;/p&gt;\n&lt;p&gt;When asynchronous components raise events, these events are generally either queued to an “originating” thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution&quot;&gt;The Solution&lt;/h2&gt;&lt;p&gt;The answer is to define some sort of “context”. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component’s current context value. If they match, then the event knows it is safe to continue; if they don’t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.&lt;/p&gt;\n&lt;p&gt;The .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.&lt;/p&gt;\n&lt;h2 id=&quot;Callback_Contexts_in_the_Real_World&quot;&gt;Callback Contexts in the Real World&lt;/h2&gt;&lt;p&gt;Fire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named “cookie”. When the timer is enabled, it allocates a new object, saves it into “cookie”, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn’t proceed with the event if they don’t match.&lt;/p&gt;\n&lt;p&gt;System.Timers.Timer does not change “cookie” when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.&lt;/p&gt;\n&lt;h2 id=&quot;Reusable_CallbackContext_Type&quot;&gt;Reusable CallbackContext Type&lt;/h2&gt;&lt;p&gt;One of the new classes in version 1.2 of the &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito Async&lt;/a&gt; library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;A delegate may be &lt;em&gt;bound&lt;/em&gt; to a CallbackContext. Binding a delegate results in a new delegate (the &lt;em&gt;bound delegate&lt;/em&gt;) - which wraps the original delegate.&lt;/li&gt;\n&lt;li&gt;Every bound delegate is either &lt;em&gt;valid&lt;/em&gt; or &lt;em&gt;invalid&lt;/em&gt;. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Delegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.&lt;/p&gt;\n&lt;p&gt;To use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.&lt;/p&gt;\n&lt;p&gt;The only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito.Async&lt;/a&gt; version 1.3.&lt;/p&gt;\n&#39;,
        excerpt: &#39;&#39;,
        more: &#39;&lt;p&gt;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.&lt;/p&gt;\n&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;End-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been “cancelled”. However, implementing this expected behavior takes some forethought.&lt;/p&gt;\n&lt;p&gt;When asynchronous components raise events, these events are generally either queued to an “originating” thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution&quot;&gt;The Solution&lt;/h2&gt;&lt;p&gt;The answer is to define some sort of “context”. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component’s current context value. If they match, then the event knows it is safe to continue; if they don’t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.&lt;/p&gt;\n&lt;p&gt;The .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.&lt;/p&gt;\n&lt;h2 id=&quot;Callback_Contexts_in_the_Real_World&quot;&gt;Callback Contexts in the Real World&lt;/h2&gt;&lt;p&gt;Fire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named “cookie”. When the timer is enabled, it allocates a new object, saves it into “cookie”, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn’t proceed with the event if they don’t match.&lt;/p&gt;\n&lt;p&gt;System.Timers.Timer does not change “cookie” when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.&lt;/p&gt;\n&lt;h2 id=&quot;Reusable_CallbackContext_Type&quot;&gt;Reusable CallbackContext Type&lt;/h2&gt;&lt;p&gt;One of the new classes in version 1.2 of the &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito Async&lt;/a&gt; library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;A delegate may be &lt;em&gt;bound&lt;/em&gt; to a CallbackContext. Binding a delegate results in a new delegate (the &lt;em&gt;bound delegate&lt;/em&gt;) - which wraps the original delegate.&lt;/li&gt;\n&lt;li&gt;Every bound delegate is either &lt;em&gt;valid&lt;/em&gt; or &lt;em&gt;invalid&lt;/em&gt;. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Delegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.&lt;/p&gt;\n&lt;p&gt;To use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.&lt;/p&gt;\n&lt;p&gt;The only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito.Async&lt;/a&gt; version 1.3.&lt;/p&gt;\n&#39;,
        path: [Getter],
        permalink: [Getter],
        full_source: [Getter],
        asset_dir: [Getter],
        tags: [Getter],
        categories: [Getter],
        prev: [Circular],
        next: 
         { layout: &#39;post&#39;,
           title: &#39;Announcing the release of Nito.Async&#39;,
           _content: &#39;\nNito Programs has released its first significant library as open-source:  \n\n  [http://www.codeplex.com/NitoAsync](http://www.codeplex.com/NitoAsync)\n\nThis library makes it easier to develop framework-agnostic components that use the [event-based asynchronous pattern](http://msdn.microsoft.com/en-us/library/wewwczdw.aspx).\n\nWhat exactly this means - and why you might care - will be expounded on in the next few blog posts.\n\n&#39;,
           source: &#39;_posts/2009-01-24-announcing-release-of-nitoasync.md&#39;,
           raw: &#39;---\nlayout: post\ntitle: &quot;Announcing the release of Nito.Async&quot;\n---\n\nNito Programs has released its first significant library as open-source:  \n\n  [http://www.codeplex.com/NitoAsync](http://www.codeplex.com/NitoAsync)\n\nThis library makes it easier to develop framework-agnostic components that use the [event-based asynchronous pattern](http://msdn.microsoft.com/en-us/library/wewwczdw.aspx).\n\nWhat exactly this means - and why you might care - will be expounded on in the next few blog posts.\n\n&#39;,
           slug: &#39;announcing-release-of-nitoasync&#39;,
           published: true,
           date: 
            { [Number: 1232773200000]
              _isAMomentObject: true,
              _i: Sat Jan 24 2009 00:00:00 GMT-0500 (Eastern Standard Time),
              _isUTC: false,
              _locale: 
               { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                 ordinal: [Function],
                 _abbr: &#39;en&#39;,
                 _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
              _d: Sat Jan 24 2009 00:00:00 GMT-0500 (Eastern Standard Time),
              _z: null,
              _pf: 
               { empty: false,
                 unusedTokens: [],
                 unusedInput: [],
                 overflow: -2,
                 charsLeftOver: 0,
                 nullInput: false,
                 invalidMonth: null,
                 invalidFormat: false,
                 userInvalidated: false,
                 iso: false },
              _isValid: true },
           updated: 
            { [Number: 1400776290638]
              _isAMomentObject: true,
              _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
              _isUTC: false,
              _locale: 
               { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                 ordinal: [Function],
                 _abbr: &#39;en&#39;,
                 _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
              _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
              _z: null },
           comments: true,
           photos: [],
           link: &#39;&#39;,
           _id: &#39;cie5tulnd0007xory43hkja7k&#39;,
           content: &#39;&lt;p&gt;Nito Programs has released its first significant library as open-source:  &lt;/p&gt;\n&lt;p&gt;  &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;http://www.codeplex.com/NitoAsync&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This library makes it easier to develop framework-agnostic components that use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wewwczdw.aspx&quot;&gt;event-based asynchronous pattern&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;What exactly this means - and why you might care - will be expounded on in the next few blog posts.&lt;/p&gt;\n&#39;,
           excerpt: &#39;&#39;,
           more: &#39;&lt;p&gt;Nito Programs has released its first significant library as open-source:  &lt;/p&gt;\n&lt;p&gt;  &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;http://www.codeplex.com/NitoAsync&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This library makes it easier to develop framework-agnostic components that use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wewwczdw.aspx&quot;&gt;event-based asynchronous pattern&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;What exactly this means - and why you might care - will be expounded on in the next few blog posts.&lt;/p&gt;\n&#39;,
           path: [Getter],
           permalink: [Getter],
           full_source: [Getter],
           asset_dir: [Getter],
           tags: [Getter],
           categories: [Getter],
           prev: [Circular],
           next: 
            { layout: &#39;post&#39;,
              title: &#39;IDisposable article published&#39;,
              _content: &#39;Today I published my first article on CodeProject: [IDisposable: What Your Mother Never Told You About Resource Deallocation](http://www.codeproject.com/KB/dotnet/IDisposable.aspx). It\&#39;s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft\&#39;s recommended IDisposable code pattern.\n\n&#39;,
              source: &#39;_posts/2008-09-21-idisposable-article-published.md&#39;,
              raw: &#39;---\nlayout: post\ntitle: &quot;IDisposable article published&quot;\n---\nToday I published my first article on CodeProject: [IDisposable: What Your Mother Never Told You About Resource Deallocation](http://www.codeproject.com/KB/dotnet/IDisposable.aspx). It\&#39;s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft\&#39;s recommended IDisposable code pattern.\n\n&#39;,
              slug: &#39;idisposable-article-published&#39;,
              published: true,
              date: 
               { [Number: 1221969600000]
                 _isAMomentObject: true,
                 _i: Sun Sep 21 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                 _isUTC: false,
                 _locale: 
                  { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: [Function],
                    _abbr: &#39;en&#39;,
                    _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                 _d: Sun Sep 21 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                 _z: null,
                 _pf: 
                  { empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false },
                 _isValid: true },
              updated: 
               { [Number: 1400776290627]
                 _isAMomentObject: true,
                 _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                 _isUTC: false,
                 _locale: 
                  { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: [Function],
                    _abbr: &#39;en&#39;,
                    _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                 _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                 _z: null },
              comments: true,
              photos: [],
              link: &#39;&#39;,
              _id: &#39;cie5tuln30002xorylmgv553t&#39;,
              content: &#39;&lt;p&gt;Today I published my first article on CodeProject: &lt;a href=&quot;http://www.codeproject.com/KB/dotnet/IDisposable.aspx&quot;&gt;IDisposable: What Your Mother Never Told You About Resource Deallocation&lt;/a&gt;. It’s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft’s recommended IDisposable code pattern.&lt;/p&gt;\n&#39;,
              excerpt: &#39;&#39;,
              more: &#39;&lt;p&gt;Today I published my first article on CodeProject: &lt;a href=&quot;http://www.codeproject.com/KB/dotnet/IDisposable.aspx&quot;&gt;IDisposable: What Your Mother Never Told You About Resource Deallocation&lt;/a&gt;. It’s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft’s recommended IDisposable code pattern.&lt;/p&gt;\n&#39;,
              path: [Getter],
              permalink: [Getter],
              full_source: [Getter],
              asset_dir: [Getter],
              tags: [Getter],
              categories: [Getter],
              prev: [Circular],
              next: 
               { layout: &#39;post&#39;,
                 title: &#39;OpenSSL 0.9.8i Binaries&#39;,
                 _content: &#39;We built the OpenSSL binaries for Windows, and made them publicly available at [http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670](http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670)\n\nNote that there are a few differences for our version, compared to other binary packages:\n\n- All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).\n- No static libraries are built; these are all DLLs.\n- Include directories and HTML documentation are packaged as well, but no import libraries.\n- No executables are included (e.g., openssl.exe).\n- The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.\n- An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.\n\n&#39;,
                 source: &#39;_posts/2008-09-16-openssl-098i-binaries.md&#39;,
                 raw: &#39;---\nlayout: post\ntitle: &quot;OpenSSL 0.9.8i Binaries&quot;\n---\nWe built the OpenSSL binaries for Windows, and made them publicly available at [http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670](http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670)\n\nNote that there are a few differences for our version, compared to other binary packages:\n\n- All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).\n- No static libraries are built; these are all DLLs.\n- Include directories and HTML documentation are packaged as well, but no import libraries.\n- No executables are included (e.g., openssl.exe).\n- The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.\n- An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.\n\n&#39;,
                 slug: &#39;openssl-098i-binaries&#39;,
                 published: true,
                 date: 
                  { [Number: 1221537600000]
                    _isAMomentObject: true,
                    _i: Tue Sep 16 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                    _isUTC: false,
                    _locale: 
                     { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                       ordinal: [Function],
                       _abbr: &#39;en&#39;,
                       _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                    _d: Tue Sep 16 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                    _z: null,
                    _pf: 
                     { empty: false,
                       unusedTokens: [],
                       unusedInput: [],
                       overflow: -2,
                       charsLeftOver: 0,
                       nullInput: false,
                       invalidMonth: null,
                       invalidFormat: false,
                       userInvalidated: false,
                       iso: false },
                    _isValid: true },
                 updated: 
                  { [Number: 1400901755274]
                    _isAMomentObject: true,
                    _i: Fri May 23 2014 23:22:35 GMT-0400 (Eastern Daylight Time),
                    _isUTC: false,
                    _locale: 
                     { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                       ordinal: [Function],
                       _abbr: &#39;en&#39;,
                       _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                    _d: Fri May 23 2014 23:22:35 GMT-0400 (Eastern Daylight Time),
                    _z: null },
                 comments: true,
                 photos: [],
                 link: &#39;&#39;,
                 _id: &#39;cie5tuln50003xoryyij63lqy&#39;,
                 content: &#39;&lt;p&gt;We built the OpenSSL binaries for Windows, and made them publicly available at &lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&quot;&gt;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Note that there are a few differences for our version, compared to other binary packages:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).&lt;/li&gt;\n&lt;li&gt;No static libraries are built; these are all DLLs.&lt;/li&gt;\n&lt;li&gt;Include directories and HTML documentation are packaged as well, but no import libraries.&lt;/li&gt;\n&lt;li&gt;No executables are included (e.g., openssl.exe).&lt;/li&gt;\n&lt;li&gt;The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;li&gt;An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
                 excerpt: &#39;&#39;,
                 more: &#39;&lt;p&gt;We built the OpenSSL binaries for Windows, and made them publicly available at &lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&quot;&gt;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Note that there are a few differences for our version, compared to other binary packages:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).&lt;/li&gt;\n&lt;li&gt;No static libraries are built; these are all DLLs.&lt;/li&gt;\n&lt;li&gt;Include directories and HTML documentation are packaged as well, but no import libraries.&lt;/li&gt;\n&lt;li&gt;No executables are included (e.g., openssl.exe).&lt;/li&gt;\n&lt;li&gt;The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;li&gt;An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
                 path: [Getter],
                 permalink: [Getter],
                 full_source: [Getter],
                 asset_dir: [Getter],
                 tags: [Getter],
                 categories: [Getter],
                 prev: [Circular],
                 next: 
                  { layout: &#39;post&#39;,
                    title: &#39;Interop documentation pointers&#39;,
                    _content: &#39;To become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here\&#39;s an attempt to bring it together, as a &quot;C++ .NET interop quick reference&quot;:\n\n- [Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke](http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx) - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages](http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx) - Details how to get C#-like behavior in C++.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR](http://msdn.microsoft.com/en-us/library/xey702bw.aspx) - Reference information for cli::pin_ptr, cli::array, managed enums, etc.\n- [.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class](http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx) - A BCL type that defines some very useful functions such as PtrToString* and StringTo*.\n\n&#39;,
                    source: &#39;_posts/2008-07-24-interop-documentation-pointers.md&#39;,
                    raw: &#39;---\nlayout: post\ntitle: &quot;Interop documentation pointers&quot;\n---\nTo become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here\&#39;s an attempt to bring it together, as a &quot;C++ .NET interop quick reference&quot;:\n\n- [Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke](http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx) - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages](http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx) - Details how to get C#-like behavior in C++.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR](http://msdn.microsoft.com/en-us/library/xey702bw.aspx) - Reference information for cli::pin_ptr, cli::array, managed enums, etc.\n- [.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class](http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx) - A BCL type that defines some very useful functions such as PtrToString* and StringTo*.\n\n&#39;,
                    slug: &#39;interop-documentation-pointers&#39;,
                    published: true,
                    date: 
                     { [Number: 1216872000000]
                       _isAMomentObject: true,
                       _i: Thu Jul 24 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                       _isUTC: false,
                       _locale: 
                        { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                          ordinal: [Function],
                          _abbr: &#39;en&#39;,
                          _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                       _d: Thu Jul 24 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                       _z: null,
                       _pf: 
                        { empty: false,
                          unusedTokens: [],
                          unusedInput: [],
                          overflow: -2,
                          charsLeftOver: 0,
                          nullInput: false,
                          invalidMonth: null,
                          invalidFormat: false,
                          userInvalidated: false,
                          iso: false },
                       _isValid: true },
                    updated: 
                     { [Number: 1400776290604]
                       _isAMomentObject: true,
                       _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                       _isUTC: false,
                       _locale: 
                        { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                          ordinal: [Function],
                          _abbr: &#39;en&#39;,
                          _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                       _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                       _z: null },
                    comments: true,
                    photos: [],
                    link: &#39;&#39;,
                    _id: &#39;cie5tulnc0006xory6w6m8p2h&#39;,
                    content: &#39;&lt;p&gt;To become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here’s an attempt to bring it together, as a “C++ .NET interop quick reference”:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke&lt;/a&gt; - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages&lt;/a&gt; - Details how to get C#-like behavior in C++.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xey702bw.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR&lt;/a&gt; - Reference information for cli::pin_ptr, cli::array, managed enums, etc.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx&quot;&gt;.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class&lt;/a&gt; - A BCL type that defines some very useful functions such as PtrToString&lt;em&gt; and StringTo&lt;/em&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
                    excerpt: &#39;&#39;,
                    more: &#39;&lt;p&gt;To become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here’s an attempt to bring it together, as a “C++ .NET interop quick reference”:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke&lt;/a&gt; - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages&lt;/a&gt; - Details how to get C#-like behavior in C++.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xey702bw.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR&lt;/a&gt; - Reference information for cli::pin_ptr, cli::array, managed enums, etc.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx&quot;&gt;.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class&lt;/a&gt; - A BCL type that defines some very useful functions such as PtrToString&lt;em&gt; and StringTo&lt;/em&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
                    path: [Getter],
                    permalink: [Getter],
                    full_source: [Getter],
                    asset_dir: [Getter],
                    tags: [Getter],
                    categories: [Getter],
                    prev: [Circular],
                    next: 
                     { layout: &#39;post&#39;,
                       title: &#39;Software-only device drivers: What\&#39;s in a name?&#39;,
                       _content: &#39;There\&#39;s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:\n\n- Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive\n- Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).\n- Virtual keyboards and mice are often used by gamepad systems\n- Virtual serial ports are used for testing or running serial programs on laptops\n- Virtual hard drives can be used as encrypted volumes\n- Other virtual devices are often developed by companies for testing purposes\n\nThe examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.\n\nThere have been a few different names tossed around to describe these drivers without hardware:\n\n - &quot;Virtual device drivers&quot; - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD\&#39;s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward &quot;virtual device driver&quot; should not be used for drivers without hardware because of the possibility of this confusion.\n - &quot;Software device drivers&quot; - this term could refer to any device driver, because they are all software. The term &quot;software device driver&quot; is in fact regularly used in this fashion, especially by those who work more with hardware.\n\nThis leaves us with the unambiguous but rather unweildly terms &quot;device driver without hardware&quot;, &quot;hardwareless device driver&quot;, or &quot;software-only device driver&quot;. Of these, the term &quot;software-only device driver&quot; seems to be getting some gradual [acceptance](http://www.google.com/search?q=%22software-only%22+device+driver) by the driver-writing community.\n\n&#39;,
                       source: &#39;_posts/2008-07-11-software-only-device-drivers-whats-in.md&#39;,
                       raw: &#39;---\nlayout: post\ntitle: &quot;Software-only device drivers: What\&#39;s in a name?&quot;\n---\nThere\&#39;s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:\n\n- Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive\n- Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).\n- Virtual keyboards and mice are often used by gamepad systems\n- Virtual serial ports are used for testing or running serial programs on laptops\n- Virtual hard drives can be used as encrypted volumes\n- Other virtual devices are often developed by companies for testing purposes\n\nThe examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.\n\nThere have been a few different names tossed around to describe these drivers without hardware:\n\n - &quot;Virtual device drivers&quot; - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD\&#39;s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward &quot;virtual device driver&quot; should not be used for drivers without hardware because of the possibility of this confusion.\n - &quot;Software device drivers&quot; - this term could refer to any device driver, because they are all software. The term &quot;software device driver&quot; is in fact regularly used in this fashion, especially by those who work more with hardware.\n\nThis leaves us with the unambiguous but rather unweildly terms &quot;device driver without hardware&quot;, &quot;hardwareless device driver&quot;, or &quot;software-only device driver&quot;. Of these, the term &quot;software-only device driver&quot; seems to be getting some gradual [acceptance](http://www.google.com/search?q=%22software-only%22+device+driver) by the driver-writing community.\n\n&#39;,
                       slug: &#39;software-only-device-drivers-whats-in&#39;,
                       published: true,
                       date: 
                        { [Number: 1215748800000]
                          _isAMomentObject: true,
                          _i: Fri Jul 11 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                          _isUTC: false,
                          _locale: 
                           { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                             ordinal: [Function],
                             _abbr: &#39;en&#39;,
                             _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                          _d: Fri Jul 11 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                          _z: null,
                          _pf: 
                           { empty: false,
                             unusedTokens: [],
                             unusedInput: [],
                             overflow: -2,
                             charsLeftOver: 0,
                             nullInput: false,
                             invalidMonth: null,
                             invalidFormat: false,
                             userInvalidated: false,
                             iso: false },
                          _isValid: true },
                       updated: 
                        { [Number: 1400776290520]
                          _isAMomentObject: true,
                          _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                          _isUTC: false,
                          _locale: 
                           { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                             ordinal: [Function],
                             _abbr: &#39;en&#39;,
                             _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                          _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                          _z: null },
                       comments: true,
                       photos: [],
                       link: &#39;&#39;,
                       _id: &#39;cie5tulmw0000xoryzylgfjrr&#39;,
                       content: &#39;&lt;p&gt;There’s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive&lt;/li&gt;\n&lt;li&gt;Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).&lt;/li&gt;\n&lt;li&gt;Virtual keyboards and mice are often used by gamepad systems&lt;/li&gt;\n&lt;li&gt;Virtual serial ports are used for testing or running serial programs on laptops&lt;/li&gt;\n&lt;li&gt;Virtual hard drives can be used as encrypted volumes&lt;/li&gt;\n&lt;li&gt;Other virtual devices are often developed by companies for testing purposes&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.&lt;/p&gt;\n&lt;p&gt;There have been a few different names tossed around to describe these drivers without hardware:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;“Virtual device drivers” - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD’s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward “virtual device driver” should not be used for drivers without hardware because of the possibility of this confusion.&lt;/li&gt;\n&lt;li&gt;“Software device drivers” - this term could refer to any device driver, because they are all software. The term “software device driver” is in fact regularly used in this fashion, especially by those who work more with hardware.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This leaves us with the unambiguous but rather unweildly terms “device driver without hardware”, “hardwareless device driver”, or “software-only device driver”. Of these, the term “software-only device driver” seems to be getting some gradual &lt;a href=&quot;http://www.google.com/search?q=%22software-only%22+device+driver&quot;&gt;acceptance&lt;/a&gt; by the driver-writing community.&lt;/p&gt;\n&#39;,
                       excerpt: &#39;&#39;,
                       more: &#39;&lt;p&gt;There’s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive&lt;/li&gt;\n&lt;li&gt;Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).&lt;/li&gt;\n&lt;li&gt;Virtual keyboards and mice are often used by gamepad systems&lt;/li&gt;\n&lt;li&gt;Virtual serial ports are used for testing or running serial programs on laptops&lt;/li&gt;\n&lt;li&gt;Virtual hard drives can be used as encrypted volumes&lt;/li&gt;\n&lt;li&gt;Other virtual devices are often developed by companies for testing purposes&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.&lt;/p&gt;\n&lt;p&gt;There have been a few different names tossed around to describe these drivers without hardware:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;“Virtual device drivers” - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD’s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward “virtual device driver” should not be used for drivers without hardware because of the possibility of this confusion.&lt;/li&gt;\n&lt;li&gt;“Software device drivers” - this term could refer to any device driver, because they are all software. The term “software device driver” is in fact regularly used in this fashion, especially by those who work more with hardware.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This leaves us with the unambiguous but rather unweildly terms “device driver without hardware”, “hardwareless device driver”, or “software-only device driver”. Of these, the term “software-only device driver” seems to be getting some gradual &lt;a href=&quot;http://www.google.com/search?q=%22software-only%22+device+driver&quot;&gt;acceptance&lt;/a&gt; by the driver-writing community.&lt;/p&gt;\n&#39;,
                       path: [Getter],
                       permalink: [Getter],
                       full_source: [Getter],
                       asset_dir: [Getter],
                       tags: [Getter],
                       categories: [Getter],
                       prev: [Circular],
                       next: 
                        { layout: &#39;post&#39;,
                          title: &#39;Soyo widescreen monitor inf available&#39;,
                          _content: &#39;This isn\&#39;t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24&quot;; this .inf file fixes two common problems:\n1. Users cannot select the native 1920x1200 resolution\n1. Games fail with a &quot;Signal out of range&quot; error\n\nLike many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a [Soyo Topaz S 24&quot; widescreen monitor](http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408)... nice.\n\nHowever, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo\&#39;s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.\n\nA lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows\&#39; restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn\&#39;t support.\n\nI was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous &quot;Signal out of range&quot; monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor\&#39;s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)\n\nSo, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor... since they weren\&#39;t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.\n\nI decided to release this little utility for free [on SourceForge](https://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=283420). This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I\&#39;ve only thoroughly tested it on Vista x64.\n\nTo install it, just right-click on the &quot;Generic Non-PnP Monitor&quot; in the Device Manager, update the drivers, and select the inf file.\n\n[![]({{ site_url }}/assets/Step+1.png)]({{ site_url }}/assets/Step+1.png)\n\nRight-click the &quot;Generic Non-PnP Monitor&quot; and select &quot;Update Driver Software...&quot;\n\n[![]({{ site_url }}/assets/Step+2.png)]({{ site_url }}/assets/Step+2.png)\n\nChoose &quot;Browse my computer for driver software&quot;\n\n[![]({{ site_url }}/assets/Step+3.png)]({{ site_url }}/assets/Step+3.png)\n\nChoose &quot;Let me pick from a list of device drivers on my computer&quot;\n\n[![]({{ site_url }}/assets/Step+4.png)]({{ site_url }}/assets/Step+4.png)\n\nClick &quot;Have Disk...&quot;\n\n[![]({{ site_url }}/assets/Step+5.png)]({{ site_url }}/assets/Step+5.png)\n\nClick &quot;Browse...&quot;\n\n[![]({{ site_url }}/assets/Step+6.png)]({{ site_url }}/assets/Step+6.png)\n\nSelect the Soyo.inf that was downloaded from SourceForge.net\n\n[![]({{ site_url }}/assets/Step+7.png)]({{ site_url }}/assets/Step+7.png)\n\nClick &quot;Next&quot;\n\n[![]({{ site_url }}/assets/Step+8.png)]({{ site_url }}/assets/Step+8.png)\n\nConfirm security question\n\nEnjoy!&#39;,
                          source: &#39;_posts/2008-07-08-soyo-widescreen-monitor-inf-available.md&#39;,
                          raw: &#39;---\nlayout: post\ntitle: &quot;Soyo widescreen monitor inf available&quot;\n---\nThis isn\&#39;t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24&quot;; this .inf file fixes two common problems:\n1. Users cannot select the native 1920x1200 resolution\n1. Games fail with a &quot;Signal out of range&quot; error\n\nLike many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a [Soyo Topaz S 24&quot; widescreen monitor](http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408)... nice.\n\nHowever, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo\&#39;s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.\n\nA lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows\&#39; restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn\&#39;t support.\n\nI was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous &quot;Signal out of range&quot; monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor\&#39;s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)\n\nSo, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor... since they weren\&#39;t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.\n\nI decided to release this little utility for free [on SourceForge](https://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=283420). This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I\&#39;ve only thoroughly tested it on Vista x64.\n\nTo install it, just right-click on the &quot;Generic Non-PnP Monitor&quot; in the Device Manager, update the drivers, and select the inf file.\n\n[![]({{ site_url }}/assets/Step+1.png)]({{ site_url }}/assets/Step+1.png)\n\nRight-click the &quot;Generic Non-PnP Monitor&quot; and select &quot;Update Driver Software...&quot;\n\n[![]({{ site_url }}/assets/Step+2.png)]({{ site_url }}/assets/Step+2.png)\n\nChoose &quot;Browse my computer for driver software&quot;\n\n[![]({{ site_url }}/assets/Step+3.png)]({{ site_url }}/assets/Step+3.png)\n\nChoose &quot;Let me pick from a list of device drivers on my computer&quot;\n\n[![]({{ site_url }}/assets/Step+4.png)]({{ site_url }}/assets/Step+4.png)\n\nClick &quot;Have Disk...&quot;\n\n[![]({{ site_url }}/assets/Step+5.png)]({{ site_url }}/assets/Step+5.png)\n\nClick &quot;Browse...&quot;\n\n[![]({{ site_url }}/assets/Step+6.png)]({{ site_url }}/assets/Step+6.png)\n\nSelect the Soyo.inf that was downloaded from SourceForge.net\n\n[![]({{ site_url }}/assets/Step+7.png)]({{ site_url }}/assets/Step+7.png)\n\nClick &quot;Next&quot;\n\n[![]({{ site_url }}/assets/Step+8.png)]({{ site_url }}/assets/Step+8.png)\n\nConfirm security question\n\nEnjoy!&#39;,
                          slug: &#39;soyo-widescreen-monitor-inf-available&#39;,
                          published: true,
                          date: 
                           { [Number: 1215489600000]
                             _isAMomentObject: true,
                             _i: Tue Jul 08 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                             _isUTC: false,
                             _locale: 
                              { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                ordinal: [Function],
                                _abbr: &#39;en&#39;,
                                _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                             _d: Tue Jul 08 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                             _z: null,
                             _pf: 
                              { empty: false,
                                unusedTokens: [],
                                unusedInput: [],
                                overflow: -2,
                                charsLeftOver: 0,
                                nullInput: false,
                                invalidMonth: null,
                                invalidFormat: false,
                                userInvalidated: false,
                                iso: false },
                             _isValid: true },
                          updated: 
                           { [Number: 1400807532690]
                             _isAMomentObject: true,
                             _i: Thu May 22 2014 21:12:12 GMT-0400 (Eastern Daylight Time),
                             _isUTC: false,
                             _locale: 
                              { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                ordinal: [Function],
                                _abbr: &#39;en&#39;,
                                _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                             _d: Thu May 22 2014 21:12:12 GMT-0400 (Eastern Daylight Time),
                             _z: null },
                          comments: true,
                          photos: [],
                          link: &#39;&#39;,
                          _id: &#39;cie5tlwcj000q1wryaipfngca&#39;,
                          content: &#39;&lt;p&gt;This isn’t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24”; this .inf file fixes two common problems:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Users cannot select the native 1920x1200 resolution&lt;/li&gt;\n&lt;li&gt;Games fail with a “Signal out of range” error&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Like many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a &lt;a href=&quot;http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408&quot;&gt;Soyo Topaz S 24” widescreen monitor&lt;/a&gt;… nice.&lt;/p&gt;\n&lt;p&gt;However, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo’s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.&lt;/p&gt;\n&lt;p&gt;A lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows’ restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn’t support.&lt;/p&gt;\n&lt;p&gt;I was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous “Signal out of range” monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor’s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)&lt;/p&gt;\n&lt;p&gt;So, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor… since they weren’t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.&lt;/p&gt;\n&lt;p&gt;I decided to release this little utility for free &lt;a href=&quot;https://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=283420&quot;&gt;on SourceForge&lt;/a&gt;. This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I’ve only thoroughly tested it on Vista x64.&lt;/p&gt;\n&lt;p&gt;To install it, just right-click on the “Generic Non-PnP Monitor” in the Device Manager, update the drivers, and select the inf file.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼1--&amp;gt;/assets/Step+1.png&quot;&gt;&lt;img src=&quot;!--￼0--&amp;gt;/assets/Step+1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Right-click the “Generic Non-PnP Monitor” and select “Update Driver Software…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼3--&amp;gt;/assets/Step+2.png&quot;&gt;&lt;img src=&quot;!--￼2--&amp;gt;/assets/Step+2.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Browse my computer for driver software”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼5--&amp;gt;/assets/Step+3.png&quot;&gt;&lt;img src=&quot;!--￼4--&amp;gt;/assets/Step+3.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Let me pick from a list of device drivers on my computer”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼7--&amp;gt;/assets/Step+4.png&quot;&gt;&lt;img src=&quot;!--￼6--&amp;gt;/assets/Step+4.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Have Disk…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼9--&amp;gt;/assets/Step+5.png&quot;&gt;&lt;img src=&quot;!--￼8--&amp;gt;/assets/Step+5.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Browse…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼11--&amp;gt;/assets/Step+6.png&quot;&gt;&lt;img src=&quot;!--￼10--&amp;gt;/assets/Step+6.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Select the Soyo.inf that was downloaded from SourceForge.net&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼13--&amp;gt;/assets/Step+7.png&quot;&gt;&lt;img src=&quot;!--￼12--&amp;gt;/assets/Step+7.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Next”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼15--&amp;gt;/assets/Step+8.png&quot;&gt;&lt;img src=&quot;!--￼14--&amp;gt;/assets/Step+8.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Confirm security question&lt;/p&gt;\n&lt;p&gt;Enjoy!&lt;/p&gt;\n&#39;,
                          excerpt: &#39;&#39;,
                          more: &#39;&lt;p&gt;This isn’t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24”; this .inf file fixes two common problems:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Users cannot select the native 1920x1200 resolution&lt;/li&gt;\n&lt;li&gt;Games fail with a “Signal out of range” error&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Like many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a &lt;a href=&quot;http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408&quot;&gt;Soyo Topaz S 24” widescreen monitor&lt;/a&gt;… nice.&lt;/p&gt;\n&lt;p&gt;However, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo’s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.&lt;/p&gt;\n&lt;p&gt;A lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows’ restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn’t support.&lt;/p&gt;\n&lt;p&gt;I was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous “Signal out of range” monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor’s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)&lt;/p&gt;\n&lt;p&gt;So, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor… since they weren’t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.&lt;/p&gt;\n&lt;p&gt;I decided to release this little utility for free &lt;a href=&quot;https://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=283420&quot;&gt;on SourceForge&lt;/a&gt;. This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I’ve only thoroughly tested it on Vista x64.&lt;/p&gt;\n&lt;p&gt;To install it, just right-click on the “Generic Non-PnP Monitor” in the Device Manager, update the drivers, and select the inf file.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼1--&amp;gt;/assets/Step+1.png&quot;&gt;&lt;img src=&quot;!--￼0--&amp;gt;/assets/Step+1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Right-click the “Generic Non-PnP Monitor” and select “Update Driver Software…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼3--&amp;gt;/assets/Step+2.png&quot;&gt;&lt;img src=&quot;!--￼2--&amp;gt;/assets/Step+2.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Browse my computer for driver software”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼5--&amp;gt;/assets/Step+3.png&quot;&gt;&lt;img src=&quot;!--￼4--&amp;gt;/assets/Step+3.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Let me pick from a list of device drivers on my computer”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼7--&amp;gt;/assets/Step+4.png&quot;&gt;&lt;img src=&quot;!--￼6--&amp;gt;/assets/Step+4.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Have Disk…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼9--&amp;gt;/assets/Step+5.png&quot;&gt;&lt;img src=&quot;!--￼8--&amp;gt;/assets/Step+5.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Browse…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼11--&amp;gt;/assets/Step+6.png&quot;&gt;&lt;img src=&quot;!--￼10--&amp;gt;/assets/Step+6.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Select the Soyo.inf that was downloaded from SourceForge.net&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼13--&amp;gt;/assets/Step+7.png&quot;&gt;&lt;img src=&quot;!--￼12--&amp;gt;/assets/Step+7.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Next”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼15--&amp;gt;/assets/Step+8.png&quot;&gt;&lt;img src=&quot;!--￼14--&amp;gt;/assets/Step+8.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Confirm security question&lt;/p&gt;\n&lt;p&gt;Enjoy!&lt;/p&gt;\n&#39;,
                          path: [Getter],
                          permalink: [Getter],
                          full_source: [Getter],
                          asset_dir: [Getter],
                          tags: [Getter],
                          categories: [Getter],
                          prev: [Circular],
                          next: 
                           { layout: &#39;post&#39;,
                             title: &#39;Free IOCTL Decoder&#39;,
                             _content: &#39;Unexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.\n\nBecause of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.\n\nOur IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).\n\nWe have decided to release this useful utility for free to the driver development community. It can be downloaded from \n[SourceForge](http://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=279739)\n\nHope you find it useful!\n\n&#39;,
                             source: &#39;_posts/2008-07-03-free-ioctl-decoder.md&#39;,
                             raw: &#39;---\nlayout: post\ntitle: &quot;Free IOCTL Decoder&quot;\n---\nUnexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.\n\nBecause of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.\n\nOur IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).\n\nWe have decided to release this useful utility for free to the driver development community. It can be downloaded from \n[SourceForge](http://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=279739)\n\nHope you find it useful!\n\n&#39;,
                             slug: &#39;free-ioctl-decoder&#39;,
                             published: true,
                             date: 
                              { [Number: 1215057600000]
                                _isAMomentObject: true,
                                _i: Thu Jul 03 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                                _isUTC: false,
                                _locale: 
                                 { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                   ordinal: [Function],
                                   _abbr: &#39;en&#39;,
                                   _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                                _d: Thu Jul 03 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                                _z: null,
                                _pf: 
                                 { empty: false,
                                   unusedTokens: [],
                                   unusedInput: [],
                                   overflow: -2,
                                   charsLeftOver: 0,
                                   nullInput: false,
                                   invalidMonth: null,
                                   invalidFormat: false,
                                   userInvalidated: false,
                                   iso: false },
                                _isValid: true },
                             updated: 
                              { [Number: 1400776290455]
                                _isAMomentObject: true,
                                _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                                _isUTC: false,
                                _locale: 
                                 { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                   ordinal: [Function],
                                   _abbr: &#39;en&#39;,
                                   _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                                _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                                _z: null },
                             comments: true,
                             photos: [],
                             link: &#39;&#39;,
                             _id: &#39;cie5tluw400021wryxy5yy127&#39;,
                             content: &#39;&lt;p&gt;Unexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.&lt;/p&gt;\n&lt;p&gt;Because of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.&lt;/p&gt;\n&lt;p&gt;Our IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).&lt;/p&gt;\n&lt;p&gt;We have decided to release this useful utility for free to the driver development community. It can be downloaded from&lt;br&gt;&lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=279739&quot;&gt;SourceForge&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Hope you find it useful!&lt;/p&gt;\n&#39;,
                             excerpt: &#39;&#39;,
                             more: &#39;&lt;p&gt;Unexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.&lt;/p&gt;\n&lt;p&gt;Because of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.&lt;/p&gt;\n&lt;p&gt;Our IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).&lt;/p&gt;\n&lt;p&gt;We have decided to release this useful utility for free to the driver development community. It can be downloaded from&lt;br&gt;&lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=279739&quot;&gt;SourceForge&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Hope you find it useful!&lt;/p&gt;\n&#39;,
                             path: [Getter],
                             permalink: [Getter],
                             full_source: [Getter],
                             asset_dir: [Getter],
                             tags: [Getter],
                             categories: [Getter],
                             prev: [Circular],
                             next: 
                              { layout: &#39;post&#39;,
                                title: &#39;Dynamically loading 32-bit or 64-bit code from a platform-agnostic executable&#39;,
                                _content: &#39;Have you ever had a `BadImageFormatException`? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine...\n\nMost Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++\&#39;s IJW) that was recently updated to support x64 and IA64 as well as x86.\n\nThe main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll\&#39;s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?\n\nWell, after spending a lot of time researching ways it wouldn\&#39;t work (`&lt;probing&gt;`, `GetSystemInfo`, `AppendPrivatePath`), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly\&#39;s `ModuleResolve` event.\n\n`IntPtr.Size` gives you a hint on how to proceed, and from there, `ModuleResolveEventHandler` just needs a bit of `try`...`catch` to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really _is_ missing).\n\n&#39;,
                                source: &#39;_posts/2008-06-20-interop-on-64-bit-platforms.md&#39;,
                                raw: &#39;---\nlayout: post\ntitle: &quot;Dynamically loading 32-bit or 64-bit code from a platform-agnostic executable&quot;\n---\nHave you ever had a `BadImageFormatException`? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine...\n\nMost Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++\&#39;s IJW) that was recently updated to support x64 and IA64 as well as x86.\n\nThe main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll\&#39;s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?\n\nWell, after spending a lot of time researching ways it wouldn\&#39;t work (`&lt;probing&gt;`, `GetSystemInfo`, `AppendPrivatePath`), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly\&#39;s `ModuleResolve` event.\n\n`IntPtr.Size` gives you a hint on how to proceed, and from there, `ModuleResolveEventHandler` just needs a bit of `try`...`catch` to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really _is_ missing).\n\n&#39;,
                                slug: &#39;interop-on-64-bit-platforms&#39;,
                                published: true,
                                date: 
                                 { [Number: 1213934400000]
                                   _isAMomentObject: true,
                                   _i: Fri Jun 20 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                                   _isUTC: false,
                                   _locale: 
                                    { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                      ordinal: [Function],
                                      _abbr: &#39;en&#39;,
                                      _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                                   _d: Fri Jun 20 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                                   _z: null,
                                   _pf: 
                                    { empty: false,
                                      unusedTokens: [],
                                      unusedInput: [],
                                      overflow: -2,
                                      charsLeftOver: 0,
                                      nullInput: false,
                                      invalidMonth: null,
                                      invalidFormat: false,
                                      userInvalidated: false,
                                      iso: false },
                                   _isValid: true },
                                updated: 
                                 { [Number: 1401196204882]
                                   _isAMomentObject: true,
                                   _i: Tue May 27 2014 09:10:04 GMT-0400 (Eastern Daylight Time),
                                   _isUTC: false,
                                   _locale: 
                                    { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                      ordinal: [Function],
                                      _abbr: &#39;en&#39;,
                                      _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                                   _d: Tue May 27 2014 09:10:04 GMT-0400 (Eastern Daylight Time),
                                   _z: null },
                                comments: true,
                                photos: [],
                                link: &#39;&#39;,
                                _id: &#39;cie5tkbb500011wry3x8f9hsb&#39;,
                                content: &#39;&lt;p&gt;Have you ever had a &lt;code&gt;BadImageFormatException&lt;/code&gt;? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine…&lt;/p&gt;\n&lt;p&gt;Most Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++’s IJW) that was recently updated to support x64 and IA64 as well as x86.&lt;/p&gt;\n&lt;p&gt;The main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll’s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?&lt;/p&gt;\n&lt;p&gt;Well, after spending a lot of time researching ways it wouldn’t work (&lt;code&gt;&amp;lt;probing&amp;gt;&lt;/code&gt;, &lt;code&gt;GetSystemInfo&lt;/code&gt;, &lt;code&gt;AppendPrivatePath&lt;/code&gt;), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly’s &lt;code&gt;ModuleResolve&lt;/code&gt; event.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;IntPtr.Size&lt;/code&gt; gives you a hint on how to proceed, and from there, &lt;code&gt;ModuleResolveEventHandler&lt;/code&gt; just needs a bit of &lt;code&gt;try&lt;/code&gt;…&lt;code&gt;catch&lt;/code&gt; to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really &lt;em&gt;is&lt;/em&gt; missing).&lt;/p&gt;\n&#39;,
                                excerpt: &#39;&#39;,
                                more: &#39;&lt;p&gt;Have you ever had a &lt;code&gt;BadImageFormatException&lt;/code&gt;? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine…&lt;/p&gt;\n&lt;p&gt;Most Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++’s IJW) that was recently updated to support x64 and IA64 as well as x86.&lt;/p&gt;\n&lt;p&gt;The main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll’s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?&lt;/p&gt;\n&lt;p&gt;Well, after spending a lot of time researching ways it wouldn’t work (&lt;code&gt;&amp;lt;probing&amp;gt;&lt;/code&gt;, &lt;code&gt;GetSystemInfo&lt;/code&gt;, &lt;code&gt;AppendPrivatePath&lt;/code&gt;), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly’s &lt;code&gt;ModuleResolve&lt;/code&gt; event.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;IntPtr.Size&lt;/code&gt; gives you a hint on how to proceed, and from there, &lt;code&gt;ModuleResolveEventHandler&lt;/code&gt; just needs a bit of &lt;code&gt;try&lt;/code&gt;…&lt;code&gt;catch&lt;/code&gt; to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really &lt;em&gt;is&lt;/em&gt; missing).&lt;/p&gt;\n&#39;,
                                path: [Getter],
                                permalink: [Getter],
                                full_source: [Getter],
                                asset_dir: [Getter],
                                tags: [Getter],
                                categories: [Getter],
                                prev: [Circular] } } } } } } } } } },
  next: 
   { layout: &#39;post&#39;,
     title: &#39;Announcing the release of Nito.Async&#39;,
     _content: &#39;\nNito Programs has released its first significant library as open-source:  \n\n  [http://www.codeplex.com/NitoAsync](http://www.codeplex.com/NitoAsync)\n\nThis library makes it easier to develop framework-agnostic components that use the [event-based asynchronous pattern](http://msdn.microsoft.com/en-us/library/wewwczdw.aspx).\n\nWhat exactly this means - and why you might care - will be expounded on in the next few blog posts.\n\n&#39;,
     source: &#39;_posts/2009-01-24-announcing-release-of-nitoasync.md&#39;,
     raw: &#39;---\nlayout: post\ntitle: &quot;Announcing the release of Nito.Async&quot;\n---\n\nNito Programs has released its first significant library as open-source:  \n\n  [http://www.codeplex.com/NitoAsync](http://www.codeplex.com/NitoAsync)\n\nThis library makes it easier to develop framework-agnostic components that use the [event-based asynchronous pattern](http://msdn.microsoft.com/en-us/library/wewwczdw.aspx).\n\nWhat exactly this means - and why you might care - will be expounded on in the next few blog posts.\n\n&#39;,
     slug: &#39;announcing-release-of-nitoasync&#39;,
     published: true,
     date: 
      { [Number: 1232773200000]
        _isAMomentObject: true,
        _i: Sat Jan 24 2009 00:00:00 GMT-0500 (Eastern Standard Time),
        _isUTC: false,
        _locale: 
         { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
           ordinal: [Function],
           _abbr: &#39;en&#39;,
           _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
        _d: Sat Jan 24 2009 00:00:00 GMT-0500 (Eastern Standard Time),
        _z: null,
        _pf: 
         { empty: false,
           unusedTokens: [],
           unusedInput: [],
           overflow: -2,
           charsLeftOver: 0,
           nullInput: false,
           invalidMonth: null,
           invalidFormat: false,
           userInvalidated: false,
           iso: false },
        _isValid: true },
     updated: 
      { [Number: 1400776290638]
        _isAMomentObject: true,
        _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
        _isUTC: false,
        _locale: 
         { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
           ordinal: [Function],
           _abbr: &#39;en&#39;,
           _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
        _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
        _z: null },
     comments: true,
     photos: [],
     link: &#39;&#39;,
     _id: &#39;cie5tulnd0007xory43hkja7k&#39;,
     content: &#39;&lt;p&gt;Nito Programs has released its first significant library as open-source:  &lt;/p&gt;\n&lt;p&gt;  &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;http://www.codeplex.com/NitoAsync&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This library makes it easier to develop framework-agnostic components that use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wewwczdw.aspx&quot;&gt;event-based asynchronous pattern&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;What exactly this means - and why you might care - will be expounded on in the next few blog posts.&lt;/p&gt;\n&#39;,
     excerpt: &#39;&#39;,
     more: &#39;&lt;p&gt;Nito Programs has released its first significant library as open-source:  &lt;/p&gt;\n&lt;p&gt;  &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;http://www.codeplex.com/NitoAsync&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;This library makes it easier to develop framework-agnostic components that use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wewwczdw.aspx&quot;&gt;event-based asynchronous pattern&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;What exactly this means - and why you might care - will be expounded on in the next few blog posts.&lt;/p&gt;\n&#39;,
     path: [Getter],
     permalink: [Getter],
     full_source: [Getter],
     asset_dir: [Getter],
     tags: [Getter],
     categories: [Getter],
     prev: 
      { layout: &#39;post&#39;,
        title: &#39;Asynchronous Callback Contexts&#39;,
        _content: &#39;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.\n\n## The Problem\n\nEnd-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been &quot;cancelled&quot;. However, implementing this expected behavior takes some forethought.\n\nWhen asynchronous components raise events, these events are generally either queued to an &quot;originating&quot; thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.\n\n## The Solution\n\nThe answer is to define some sort of &quot;context&quot;. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component\&#39;s current context value. If they match, then the event knows it is safe to continue; if they don\&#39;t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.\n\nThe .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.\n\n## Callback Contexts in the Real World\n\nFire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named &quot;cookie&quot;. When the timer is enabled, it allocates a new object, saves it into &quot;cookie&quot;, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn\&#39;t proceed with the event if they don\&#39;t match.\n\nSystem.Timers.Timer does not change &quot;cookie&quot; when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.\n\n## Reusable CallbackContext Type\n\nOne of the new classes in version 1.2 of the [Nito Async](http://nitoasync.codeplex.com/) library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:\n\n- A delegate may be _bound_ to a CallbackContext. Binding a delegate results in a new delegate (the _bound delegate_) - which wraps the original delegate.\n- Every bound delegate is either _valid_ or _invalid_. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.\n\nDelegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.\n\nTo use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.\n\nThe only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in [Nito.Async](http://nitoasync.codeplex.com/) version 1.3.\n\n&#39;,
        source: &#39;_posts/2009-04-24-asynchronous-callback-contexts.md&#39;,
        raw: &#39;---\nlayout: post\ntitle: &quot;Asynchronous Callback Contexts&quot;\n---\nOne major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.\n\n## The Problem\n\nEnd-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been &quot;cancelled&quot;. However, implementing this expected behavior takes some forethought.\n\nWhen asynchronous components raise events, these events are generally either queued to an &quot;originating&quot; thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.\n\n## The Solution\n\nThe answer is to define some sort of &quot;context&quot;. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component\&#39;s current context value. If they match, then the event knows it is safe to continue; if they don\&#39;t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.\n\nThe .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.\n\n## Callback Contexts in the Real World\n\nFire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named &quot;cookie&quot;. When the timer is enabled, it allocates a new object, saves it into &quot;cookie&quot;, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn\&#39;t proceed with the event if they don\&#39;t match.\n\nSystem.Timers.Timer does not change &quot;cookie&quot; when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.\n\n## Reusable CallbackContext Type\n\nOne of the new classes in version 1.2 of the [Nito Async](http://nitoasync.codeplex.com/) library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:\n\n- A delegate may be _bound_ to a CallbackContext. Binding a delegate results in a new delegate (the _bound delegate_) - which wraps the original delegate.\n- Every bound delegate is either _valid_ or _invalid_. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.\n\nDelegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.\n\nTo use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.\n\nThe only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in [Nito.Async](http://nitoasync.codeplex.com/) version 1.3.\n\n&#39;,
        slug: &#39;asynchronous-callback-contexts&#39;,
        published: true,
        date: 
         { [Number: 1240545600000]
           _isAMomentObject: true,
           _i: Fri Apr 24 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Fri Apr 24 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
           _z: null,
           _pf: 
            { empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false },
           _isValid: true },
        updated: 
         { [Number: 1400776290662]
           _isAMomentObject: true,
           _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
           _z: null },
        comments: true,
        photos: [],
        link: &#39;&#39;,
        _id: &#39;cie5tuln00001xorynzsev89f&#39;,
        content: &#39;&lt;p&gt;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.&lt;/p&gt;\n&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;End-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been “cancelled”. However, implementing this expected behavior takes some forethought.&lt;/p&gt;\n&lt;p&gt;When asynchronous components raise events, these events are generally either queued to an “originating” thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution&quot;&gt;The Solution&lt;/h2&gt;&lt;p&gt;The answer is to define some sort of “context”. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component’s current context value. If they match, then the event knows it is safe to continue; if they don’t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.&lt;/p&gt;\n&lt;p&gt;The .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.&lt;/p&gt;\n&lt;h2 id=&quot;Callback_Contexts_in_the_Real_World&quot;&gt;Callback Contexts in the Real World&lt;/h2&gt;&lt;p&gt;Fire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named “cookie”. When the timer is enabled, it allocates a new object, saves it into “cookie”, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn’t proceed with the event if they don’t match.&lt;/p&gt;\n&lt;p&gt;System.Timers.Timer does not change “cookie” when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.&lt;/p&gt;\n&lt;h2 id=&quot;Reusable_CallbackContext_Type&quot;&gt;Reusable CallbackContext Type&lt;/h2&gt;&lt;p&gt;One of the new classes in version 1.2 of the &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito Async&lt;/a&gt; library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;A delegate may be &lt;em&gt;bound&lt;/em&gt; to a CallbackContext. Binding a delegate results in a new delegate (the &lt;em&gt;bound delegate&lt;/em&gt;) - which wraps the original delegate.&lt;/li&gt;\n&lt;li&gt;Every bound delegate is either &lt;em&gt;valid&lt;/em&gt; or &lt;em&gt;invalid&lt;/em&gt;. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Delegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.&lt;/p&gt;\n&lt;p&gt;To use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.&lt;/p&gt;\n&lt;p&gt;The only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito.Async&lt;/a&gt; version 1.3.&lt;/p&gt;\n&#39;,
        excerpt: &#39;&#39;,
        more: &#39;&lt;p&gt;One major - and often overlooked - issue when designing asynchronous components is the difficulty of cancellation, particularly during object disposal.&lt;/p&gt;\n&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;End-users do not expect components to raise events after they have been disposed. It is natural to assume that after an object has been disposed of, it will not raise an event some time in the future. Likewise, if the component has repeating events and supports cancellation, it is reasonable to assume that the events will stop firing after the component has been “cancelled”. However, implementing this expected behavior takes some forethought.&lt;/p&gt;\n&lt;p&gt;When asynchronous components raise events, these events are generally either queued to an “originating” thread or queued to be executed by the ThreadPool. Usually, it is a simple matter to cancel an upcoming event as long as it is not yet queued; the trick comes in how to handle cancelled events that have already been queued.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution&quot;&gt;The Solution&lt;/h2&gt;&lt;p&gt;The answer is to define some sort of “context”. When the component queues an event, it copies the current value of the context, and when the event is actually processed, it first checks its value of the context against the component’s current context value. If they match, then the event knows it is safe to continue; if they don’t match, then the event knows it has been cancelled. The component then just changes its context value whenever it is cancelled or disposed.&lt;/p&gt;\n&lt;p&gt;The .NET framework provides an excellent choice for contexts: object. Objects are compared using fast reference equality and they are fast to allocate and deallocate. A component includes an object reference as its context, and allocates a new one when it is cancelled or disposed. Earlier versions of Nito.Async asynchronous components used exactly this method.&lt;/p&gt;\n&lt;h2 id=&quot;Callback_Contexts_in_the_Real_World&quot;&gt;Callback Contexts in the Real World&lt;/h2&gt;&lt;p&gt;Fire up Reflector and take a look at System.Timers.Timer in System.dll (2.0.0.0). It has a private field of type object named “cookie”. When the timer is enabled, it allocates a new object, saves it into “cookie”, and passes it as the state object to the underlying System.Threading.Timer callback. The underlying timer callback (in MyTimerCallback) compares the state object to the current value of cookie, and doesn’t proceed with the event if they don’t match.&lt;/p&gt;\n&lt;p&gt;System.Timers.Timer does not change “cookie” when it is disposed because the underlying System.Threading.Timer will not invoke its TimerCallback after it has been disposed. At first glance this appears correct, but this is actually a race condition bug because there is a possibility of System.Timers.Timer.Elapsed being invoked while another thread is executing System.Timers.Timer.Close. If SynchronizingObject is non-null, MyTimerCallback may queue the callback to the thread executing Dispose, resulting in a situation where an event (Elapsed) is fired after the object has been disposed.&lt;/p&gt;\n&lt;h2 id=&quot;Reusable_CallbackContext_Type&quot;&gt;Reusable CallbackContext Type&lt;/h2&gt;&lt;p&gt;One of the new classes in version 1.2 of the &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito Async&lt;/a&gt; library is a reusable CallbackContext type. This class encapsulates all the semantics necessary, and introduces a few new terms:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;A delegate may be &lt;em&gt;bound&lt;/em&gt; to a CallbackContext. Binding a delegate results in a new delegate (the &lt;em&gt;bound delegate&lt;/em&gt;) - which wraps the original delegate.&lt;/li&gt;\n&lt;li&gt;Every bound delegate is either &lt;em&gt;valid&lt;/em&gt; or &lt;em&gt;invalid&lt;/em&gt;. When a valid delegate executes, it will execute its wrapped delegate; when an invalid delegate executes, it will do nothing.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Delegates are bound to the CallbackContext by calling CallbackContext.Bind; delegates are valid when they are bound. A CallbackContext will invalidate all of its bound delegates when CallbackContext.Reset is called.&lt;/p&gt;\n&lt;p&gt;To use CallbackContext from an asynchronous component, bind each delegate that needs to check the context. Then call CallbackContext.Reset when the operation is cancelled. CallbackContext also derives from IDisposable and implements Dispose (as a synonym for Reset) to remind users to call CallbackContext.Dispose when the asynchronous component is disposed.&lt;/p&gt;\n&lt;p&gt;The only other note regarding CallbackContext is that the delegates should be synchronized (using SynchronizingObject or SynchronizationContext) before the bound delegate is invoked. We are considering adding overloads to CallbackContext to allow for synchronization and binding in a single step, ensuring the correct order; if they are added, they will be included in &lt;a href=&quot;http://nitoasync.codeplex.com/&quot;&gt;Nito.Async&lt;/a&gt; version 1.3.&lt;/p&gt;\n&#39;,
        path: [Getter],
        permalink: [Getter],
        full_source: [Getter],
        asset_dir: [Getter],
        tags: [Getter],
        categories: [Getter],
        prev: 
         { layout: &#39;post&#39;,
           title: &#39;Sample code: Length-prefix message framing for streams&#39;,
           series: &#39;TCP/IP .NET Sockets FAQ&#39;,
           seriesTitle: &#39;Length-Prefix Example&#39;,
           _content: &#39;The necessity of message framing is discussed at [http://blog.stephencleary.com/2009/04/message-framing.html]({% post_url 2009-04-30-message-framing %}).\n\nThe class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the [Nito.Async](http://www.codeplex.com/NitoAsync) library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.\n\nNote that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.\n\n```cs\n// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html\n/// &lt;summary&gt;\n/// Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// &lt;para&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;see cref=&quot;MessageArrived&quot;/&gt;. As bytes arrive at the stream, pass them to &lt;see cref=&quot;DataReceived&quot;/&gt;, which will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.&lt;/para&gt;\n/// &lt;para&gt;If &lt;see cref=&quot;DataReceived&quot;/&gt; raises &lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance.&lt;/para&gt;\n/// &lt;para&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;/para&gt;\n/// &lt;para&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;/para&gt;\n/// &lt;/remarks&gt;\npublic class PacketProtocol\n{\n    /// &lt;summary&gt;\n    /// Wraps a message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;message&quot;&gt;The message to send.&lt;/param&gt;\n    public static byte[] WrapMessage(byte[] message)\n    {\n        // Get the length prefix for the message\n        byte[] lengthPrefix = BitConverter.GetBytes(message.Length);\n  \n        // Concatenate the length prefix and the message\n        byte[] ret = new byte[lengthPrefix.Length + message.Length];\n        lengthPrefix.CopyTo(ret, 0);\n        message.CopyTo(ret, lengthPrefix.Length);\n  \n        return ret;\n    }\n  \n    /// &lt;summary&gt;\n    /// Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    public static byte[] WrapKeepaliveMessage()\n    {\n        return BitConverter.GetBytes((int)0);\n    }\n  \n    /// &lt;summary&gt;\n    /// Initializes a new &lt;see cref=&quot;PacketProtocol&quot;/&gt;, limiting message sizes to the given maximum size.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;maxMessageSize&quot;&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;/param&gt;\n    public PacketProtocol(int maxMessageSize)\n    {\n        // We allocate the buffer for receiving message lengths immediately\n        this.lengthBuffer = new byte[sizeof(int)];\n        this.maxMessageSize = maxMessageSize;\n    }\n  \n    /// &lt;summary&gt;\n    /// The buffer for the length prefix; this is always 4 bytes long.\n    /// &lt;/summary&gt;\n    private byte[] lengthBuffer;\n  \n    /// &lt;summary&gt;\n    /// The buffer for the data; this is null if we are receiving the length prefix buffer.\n    /// &lt;/summary&gt;\n    private byte[] dataBuffer;\n  \n    /// &lt;summary&gt;\n    /// The number of bytes already read into the buffer (the length buffer if &lt;see cref=&quot;dataBuffer&quot;/&gt; is null, otherwise the data buffer).\n    /// &lt;/summary&gt;\n    private int bytesReceived;\n  \n    /// &lt;summary&gt;\n    /// The maximum size of messages allowed.\n    /// &lt;/summary&gt;\n    private int maxMessageSize;\n  \n    /// &lt;summary&gt;\n    /// Indicates the completion of a message read from the stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;/para&gt;\n    /// &lt;para&gt;This event is invoked from within a call to &lt;see cref=&quot;DataReceived&quot;/&gt;. Handlers for this event should not call &lt;see cref=&quot;DataReceived&quot;/&gt;.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    public Action&lt;byte[]&gt; MessageArrived { get; set; }\n  \n    /// &lt;summary&gt;\n    /// Notifies the &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance that incoming data has been received from the stream. This method will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This method may invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; zero or more times.&lt;/para&gt;\n    /// &lt;para&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;see cref=&quot;PacketProtocol&quot;/&gt; takes no action in this case.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;data&quot;&gt;The data received from the stream. Cannot be null.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    public void DataReceived(byte[] data)\n    {\n        // Process the incoming data in chunks, as the ReadCompleted requests it\n  \n        // Logically, we are satisfying read requests with the received data, instead of processing the\n        //  incoming buffer looking for messages.\n  \n        int i = 0;\n        while (i != data.Length)\n        {\n            // Determine how many bytes we want to transfer to the buffer and transfer them\n            int bytesAvailable = data.Length - i;\n            if (this.dataBuffer != null)\n            {\n                // We\&#39;re reading into the data buffer\n                int bytesRequested = this.dataBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.dataBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n            else\n            {\n                // We\&#39;re reading into the length prefix buffer\n                int bytesRequested = this.lengthBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.lengthBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n        }\n    }\n  \n    /// &lt;summary&gt;\n    /// Called when a read completes. Parses the received data and calls &lt;see cref=&quot;MessageArrived&quot;/&gt; if necessary.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;count&quot;&gt;The number of bytes read.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    private void ReadCompleted(int count)\n    {\n        // Get the number of bytes read into the buffer\n        this.bytesReceived += count;\n  \n        if (this.dataBuffer == null)\n        {\n            // We\&#39;re currently receiving the length buffer\n  \n            if (this.bytesReceived != sizeof(int))\n            {\n                // We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten the length buffer\n                int length = BitConverter.ToInt32(this.lengthBuffer, 0);\n  \n                // Sanity check for length &lt; 0\n                if (length &lt; 0)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length is less than zero&quot;);\n  \n                // Another sanity check is needed here for very large packets, to prevent denial-of-service attacks\n                if (this.maxMessageSize &gt; 0 &amp;&amp; length &gt; this.maxMessageSize)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length &quot; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &quot; is larger than maximum message size &quot; + this.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));\n  \n                // Zero-length packets are allowed as keepalives\n                if (length == 0)\n                {\n                    this.bytesReceived = 0;\n                    if (this.MessageArrived != null)\n                        this.MessageArrived(new byte[0]);\n                }\n                else\n                {\n                    // Create the data buffer and start reading into it\n                    this.dataBuffer = new byte[length];\n                    this.bytesReceived = 0;\n                }\n            }\n        }\n        else\n        {\n            if (this.bytesReceived != this.dataBuffer.Length)\n            {\n                // We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten an entire packet\n                if (this.MessageArrived != null)\n                    this.MessageArrived(this.dataBuffer);\n  \n                // Start reading the length buffer again\n                this.dataBuffer = null;\n                this.bytesReceived = 0;\n            }\n        }\n    }\n}\n```\n&#39;,
           source: &#39;_posts/2009-04-30-sample-code-length-prefix-message.md&#39;,
           raw: &#39;---\nlayout: post\ntitle: &quot;Sample code: Length-prefix message framing for streams&quot;\nseries: &quot;TCP/IP .NET Sockets FAQ&quot;\nseriesTitle: &quot;Length-Prefix Example&quot;\n---\nThe necessity of message framing is discussed at [http://blog.stephencleary.com/2009/04/message-framing.html]({% post_url 2009-04-30-message-framing %}).\n\nThe class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the [Nito.Async](http://www.codeplex.com/NitoAsync) library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.\n\nNote that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.\n\n```cs\n// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html\n/// &lt;summary&gt;\n/// Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.\n/// &lt;/summary&gt;\n/// &lt;remarks&gt;\n/// &lt;para&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;see cref=&quot;MessageArrived&quot;/&gt;. As bytes arrive at the stream, pass them to &lt;see cref=&quot;DataReceived&quot;/&gt;, which will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.&lt;/para&gt;\n/// &lt;para&gt;If &lt;see cref=&quot;DataReceived&quot;/&gt; raises &lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance.&lt;/para&gt;\n/// &lt;para&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;/para&gt;\n/// &lt;para&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;/para&gt;\n/// &lt;/remarks&gt;\npublic class PacketProtocol\n{\n    /// &lt;summary&gt;\n    /// Wraps a message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;message&quot;&gt;The message to send.&lt;/param&gt;\n    public static byte[] WrapMessage(byte[] message)\n    {\n        // Get the length prefix for the message\n        byte[] lengthPrefix = BitConverter.GetBytes(message.Length);\n  \n        // Concatenate the length prefix and the message\n        byte[] ret = new byte[lengthPrefix.Length + message.Length];\n        lengthPrefix.CopyTo(ret, 0);\n        message.CopyTo(ret, lengthPrefix.Length);\n  \n        return ret;\n    }\n  \n    /// &lt;summary&gt;\n    /// Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.\n    /// &lt;/summary&gt;\n    public static byte[] WrapKeepaliveMessage()\n    {\n        return BitConverter.GetBytes((int)0);\n    }\n  \n    /// &lt;summary&gt;\n    /// Initializes a new &lt;see cref=&quot;PacketProtocol&quot;/&gt;, limiting message sizes to the given maximum size.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;maxMessageSize&quot;&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;/param&gt;\n    public PacketProtocol(int maxMessageSize)\n    {\n        // We allocate the buffer for receiving message lengths immediately\n        this.lengthBuffer = new byte[sizeof(int)];\n        this.maxMessageSize = maxMessageSize;\n    }\n  \n    /// &lt;summary&gt;\n    /// The buffer for the length prefix; this is always 4 bytes long.\n    /// &lt;/summary&gt;\n    private byte[] lengthBuffer;\n  \n    /// &lt;summary&gt;\n    /// The buffer for the data; this is null if we are receiving the length prefix buffer.\n    /// &lt;/summary&gt;\n    private byte[] dataBuffer;\n  \n    /// &lt;summary&gt;\n    /// The number of bytes already read into the buffer (the length buffer if &lt;see cref=&quot;dataBuffer&quot;/&gt; is null, otherwise the data buffer).\n    /// &lt;/summary&gt;\n    private int bytesReceived;\n  \n    /// &lt;summary&gt;\n    /// The maximum size of messages allowed.\n    /// &lt;/summary&gt;\n    private int maxMessageSize;\n  \n    /// &lt;summary&gt;\n    /// Indicates the completion of a message read from the stream.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;/para&gt;\n    /// &lt;para&gt;This event is invoked from within a call to &lt;see cref=&quot;DataReceived&quot;/&gt;. Handlers for this event should not call &lt;see cref=&quot;DataReceived&quot;/&gt;.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    public Action&lt;byte[]&gt; MessageArrived { get; set; }\n  \n    /// &lt;summary&gt;\n    /// Notifies the &lt;see cref=&quot;PacketProtocol&quot;/&gt; instance that incoming data has been received from the stream. This method will invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; as necessary.\n    /// &lt;/summary&gt;\n    /// &lt;remarks&gt;\n    /// &lt;para&gt;This method may invoke &lt;see cref=&quot;MessageArrived&quot;/&gt; zero or more times.&lt;/para&gt;\n    /// &lt;para&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;see cref=&quot;PacketProtocol&quot;/&gt; takes no action in this case.&lt;/para&gt;\n    /// &lt;/remarks&gt;\n    /// &lt;param name=&quot;data&quot;&gt;The data received from the stream. Cannot be null.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    public void DataReceived(byte[] data)\n    {\n        // Process the incoming data in chunks, as the ReadCompleted requests it\n  \n        // Logically, we are satisfying read requests with the received data, instead of processing the\n        //  incoming buffer looking for messages.\n  \n        int i = 0;\n        while (i != data.Length)\n        {\n            // Determine how many bytes we want to transfer to the buffer and transfer them\n            int bytesAvailable = data.Length - i;\n            if (this.dataBuffer != null)\n            {\n                // We\&#39;re reading into the data buffer\n                int bytesRequested = this.dataBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.dataBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n            else\n            {\n                // We\&#39;re reading into the length prefix buffer\n                int bytesRequested = this.lengthBuffer.Length - this.bytesReceived;\n  \n                // Copy the incoming bytes into the buffer\n                int bytesTransferred = Math.Min(bytesRequested, bytesAvailable);\n                Array.Copy(data, i, this.lengthBuffer, this.bytesReceived, bytesTransferred);\n                i += bytesTransferred;\n  \n                // Notify &quot;read completion&quot;\n                this.ReadCompleted(bytesTransferred);\n            }\n        }\n    }\n  \n    /// &lt;summary&gt;\n    /// Called when a read completes. Parses the received data and calls &lt;see cref=&quot;MessageArrived&quot;/&gt; if necessary.\n    /// &lt;/summary&gt;\n    /// &lt;param name=&quot;count&quot;&gt;The number of bytes read.&lt;/param&gt;\n    /// &lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&gt;If the data received is not a properly-formed message.&lt;/exception&gt;\n    private void ReadCompleted(int count)\n    {\n        // Get the number of bytes read into the buffer\n        this.bytesReceived += count;\n  \n        if (this.dataBuffer == null)\n        {\n            // We\&#39;re currently receiving the length buffer\n  \n            if (this.bytesReceived != sizeof(int))\n            {\n                // We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten the length buffer\n                int length = BitConverter.ToInt32(this.lengthBuffer, 0);\n  \n                // Sanity check for length &lt; 0\n                if (length &lt; 0)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length is less than zero&quot;);\n  \n                // Another sanity check is needed here for very large packets, to prevent denial-of-service attacks\n                if (this.maxMessageSize &gt; 0 &amp;&amp; length &gt; this.maxMessageSize)\n                    throw new System.Net.ProtocolViolationException(&quot;Message length &quot; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &quot; is larger than maximum message size &quot; + this.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));\n  \n                // Zero-length packets are allowed as keepalives\n                if (length == 0)\n                {\n                    this.bytesReceived = 0;\n                    if (this.MessageArrived != null)\n                        this.MessageArrived(new byte[0]);\n                }\n                else\n                {\n                    // Create the data buffer and start reading into it\n                    this.dataBuffer = new byte[length];\n                    this.bytesReceived = 0;\n                }\n            }\n        }\n        else\n        {\n            if (this.bytesReceived != this.dataBuffer.Length)\n            {\n                // We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive\n            }\n            else\n            {\n                // We\&#39;ve gotten an entire packet\n                if (this.MessageArrived != null)\n                    this.MessageArrived(this.dataBuffer);\n  \n                // Start reading the length buffer again\n                this.dataBuffer = null;\n                this.bytesReceived = 0;\n            }\n        }\n    }\n}\n```\n&#39;,
           slug: &#39;sample-code-length-prefix-message&#39;,
           published: true,
           date: 
            { [Number: 1241064000000]
              _isAMomentObject: true,
              _i: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
              _isUTC: false,
              _locale: 
               { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                 ordinal: [Function],
                 _abbr: &#39;en&#39;,
                 _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
              _d: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
              _z: null,
              _pf: 
               { empty: false,
                 unusedTokens: [],
                 unusedInput: [],
                 overflow: -2,
                 charsLeftOver: 0,
                 nullInput: false,
                 invalidMonth: null,
                 invalidFormat: false,
                 userInvalidated: false,
                 iso: false },
              _isValid: true },
           updated: 
            { [Number: 1441382486515]
              _isAMomentObject: true,
              _i: Fri Sep 04 2015 12:01:26 GMT-0400 (Eastern Daylight Time),
              _isUTC: false,
              _locale: 
               { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                 ordinal: [Function],
                 _abbr: &#39;en&#39;,
                 _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
              _d: Fri Sep 04 2015 12:01:26 GMT-0400 (Eastern Daylight Time),
              _z: null },
           _id: &#39;cie5tuln80004xorympah9d37&#39;,
           comments: true,
           photos: [],
           link: &#39;&#39;,
           content: &#39;&lt;p&gt;The necessity of message framing is discussed at &lt;a href=&quot;!--￼1--&quot;&gt;http://blog.stephencleary.com/2009/04/message-framing.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.&lt;/p&gt;\n&lt;p&gt;Note that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.&lt;/p&gt;\n&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;182&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;183&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;184&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;185&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;186&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;187&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;188&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;189&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;190&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;191&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;193&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;195&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt;. As bytes arrive at the stream, pass them to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;, which will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;If &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt; raises &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&amp;gt;&lt;/span&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;The message to send.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapMessage(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the length prefix for the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthPrefix = BitConverter.GetBytes(message.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Concatenate the length prefix and the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[lengthPrefix.Length + message.Length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lengthPrefix.CopyTo(ret, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message.CopyTo(ret, lengthPrefix.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapKeepaliveMessage()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; BitConverter.GetBytes((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Initializes a new &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt;, limiting message sizes to the given maximum size.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;maxMessageSize&quot;&amp;gt;&lt;/span&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// We allocate the buffer for receiving message lengths immediately&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize = maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the length prefix; this is always 4 bytes long.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the data; this is null if we are receiving the length prefix buffer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] dataBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The number of bytes already read into the buffer (the length buffer if &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;dataBuffer&quot;/&amp;gt;&lt;/span&gt; is null, otherwise the data buffer).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The maximum size of messages allowed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Indicates the completion of a message read from the stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This event is invoked from within a call to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;. Handlers for this event should not call &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Action&amp;lt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; MessageArrived &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Notifies the &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance that incoming data has been received from the stream. This method will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This method may invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; zero or more times.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; takes no action in this case.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&lt;/span&gt;The data received from the stream. Cannot be null.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataReceived&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] data&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process the incoming data in chunks, as the ReadCompleted requests it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Logically, we are satisfying read requests with the received data, instead of processing the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//  incoming buffer looking for messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i != data.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Determine how many bytes we want to transfer to the buffer and transfer them&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesAvailable = data.Length - i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the data buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the length prefix buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Called when a read completes. Parses the received data and calls &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; if necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&lt;/span&gt;The number of bytes read.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReadCompleted&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the number of bytes read into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived += count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// We\&#39;re currently receiving the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length = BitConverter.ToInt32(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Sanity check for length &amp;lt; 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length is less than zero&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Another sanity check is needed here for very large packets, to prevent denial-of-service attacks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; length &amp;gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length &quot;&lt;/span&gt; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &lt;span class=&quot;string&quot;&gt;&quot; is larger than maximum message size &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Zero-length packets are allowed as keepalives&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Create the data buffer and start reading into it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten an entire packet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Start reading the length buffer again&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;\n&#39;,
           excerpt: &#39;&#39;,
           more: &#39;&lt;p&gt;The necessity of message framing is discussed at &lt;a href=&quot;!--￼1--&quot;&gt;http://blog.stephencleary.com/2009/04/message-framing.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The class below is a modified version of Nito.Async.Sockets.SocketPacketProtocol from the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library. The main difference is that the Nito.Async.Sockets.SocketPacketProtocol class communicates directly with the asynchronous Nito socket classes, allowing a more efficient implementation. The PacketProtocol class below is slightly less efficient, but can be used with any socket classes, including synchronous sockets or even non-socket streams such as files.&lt;/p&gt;\n&lt;p&gt;Note that PacketProtocol is not threadsafe, so the instance members of this class must be synchronized when necessary.&lt;/p&gt;\n&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;136&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;137&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;138&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;139&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;140&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;141&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;142&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;144&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;145&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;146&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;147&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;148&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;149&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;150&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;151&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;152&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;153&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;154&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;155&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;156&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;157&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;158&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;159&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;160&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;161&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;162&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;163&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;164&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;165&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;166&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;167&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;168&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;169&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;170&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;171&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;172&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;173&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;174&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;175&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;176&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;177&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;178&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;179&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;181&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;182&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;183&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;184&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;185&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;186&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;187&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;188&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;189&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;190&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;191&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;192&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;193&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;195&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Original source: http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Maintains the necessary buffers for applying a length-prefix message framing protocol over a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Create one instance of this class for each incoming stream, and assign a handler to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt;. As bytes arrive at the stream, pass them to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;, which will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;If &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt; raises &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;System.Net.ProtocolViolationException&quot;/&amp;gt;&lt;/span&gt;, then the stream data should be considered invalid. After that point, no methods should be called on that &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This class uses a 4-byte signed integer length prefix, which allows for message sizes up to 2 GB. Keepalive messages are supported as messages with a length prefix of 0 and no message data.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This is EXAMPLE CODE! It is not particularly efficient; in particular, if this class is rewritten so that a particular interface is used (e.g., Socket\&#39;s IAsyncResult methods), some buffer copies become unnecessary and may be removed.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Generates a length prefix for the message and returns the combined length prefix and message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;message&quot;&amp;gt;&lt;/span&gt;The message to send.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapMessage(&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the length prefix for the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthPrefix = BitConverter.GetBytes(message.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Concatenate the length prefix and the message&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] ret = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[lengthPrefix.Length + message.Length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lengthPrefix.CopyTo(ret, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        message.CopyTo(ret, lengthPrefix.Length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Wraps a keepalive (0-length) message. The wrapped message is ready to send to a stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] WrapKeepaliveMessage()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; BitConverter.GetBytes((&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Initializes a new &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt;, limiting message sizes to the given maximum size.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;maxMessageSize&quot;&amp;gt;&lt;/span&gt;The maximum message size supported by this protocol. This may be less than or equal to zero to indicate no maximum message size.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PacketProtocol&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// We allocate the buffer for receiving message lengths immediately&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize = maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the length prefix; this is always 4 bytes long.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] lengthBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The buffer for the data; this is null if we are receiving the length prefix buffer.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] dataBuffer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The number of bytes already read into the buffer (the length buffer if &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;dataBuffer&quot;/&amp;gt;&lt;/span&gt; is null, otherwise the data buffer).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; The maximum size of messages allowed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maxMessageSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Indicates the completion of a message read from the stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This may be called with an empty message, indicating that the other end had sent a keepalive message. This will never be called with a null message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This event is invoked from within a call to &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;. Handlers for this event should not call &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;DataReceived&quot;/&amp;gt;&lt;/span&gt;.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Action&amp;lt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[]&amp;gt; MessageArrived &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Notifies the &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; instance that incoming data has been received from the stream. This method will invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; as necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;This method may invoke &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; zero or more times.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;para&amp;gt;&lt;/span&gt;Zero-length receives are ignored. Many streams use a 0-length read to indicate the end of a stream, but &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;PacketProtocol&quot;/&amp;gt;&lt;/span&gt; takes no action in this case.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/para&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&lt;/span&gt;The data received from the stream. Cannot be null.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;DataReceived&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] data&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process the incoming data in chunks, as the ReadCompleted requests it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Logically, we are satisfying read requests with the received data, instead of processing the&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//  incoming buffer looking for messages.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i != data.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Determine how many bytes we want to transfer to the buffer and transfer them&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesAvailable = data.Length - i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the data buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;re reading into the length prefix buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesRequested = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer.Length - &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Copy the incoming bytes into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; bytesTransferred = Math.Min(bytesRequested, bytesAvailable);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Array.Copy(data, i, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived, bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i += bytesTransferred;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Notify &quot;read completion&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.ReadCompleted(bytesTransferred);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; Called when a read completes. Parses the received data and calls &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;see cref=&quot;MessageArrived&quot;/&amp;gt;&lt;/span&gt; if necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&lt;/span&gt;The number of bytes read.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;xmlDocTag&quot;&gt;///&lt;/span&gt; &lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;exception cref=&quot;System.Net.ProtocolViolationException&quot;&amp;gt;&lt;/span&gt;If the data received is not a properly-formed message.&lt;span class=&quot;xmlDocTag&quot;&gt;&amp;lt;/exception&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReadCompleted&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; count&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the number of bytes read into the buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived += count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// We\&#39;re currently receiving the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the length buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten the length buffer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; length = BitConverter.ToInt32(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.lengthBuffer, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Sanity check for length &amp;lt; 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length is less than zero&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Another sanity check is needed here for very large packets, to prevent denial-of-service attacks&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; length &amp;gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; System.Net.ProtocolViolationException(&lt;span class=&quot;string&quot;&gt;&quot;Message length &quot;&lt;/span&gt; + length.ToString(System.Globalization.CultureInfo.InvariantCulture) + &lt;span class=&quot;string&quot;&gt;&quot; is larger than maximum message size &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maxMessageSize.ToString(System.Globalization.CultureInfo.InvariantCulture));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Zero-length packets are allowed as keepalives&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (length == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Create the data buffer and start reading into it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived != &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer.Length)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We haven\&#39;t gotten all the data buffer yet: just wait for more data to arrive&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// We\&#39;ve gotten an entire packet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.MessageArrived(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Start reading the length buffer again&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.dataBuffer = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.bytesReceived = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;\n&#39;,
           path: [Getter],
           permalink: [Getter],
           full_source: [Getter],
           asset_dir: [Getter],
           tags: [Getter],
           categories: [Getter],
           prev: 
            { layout: &#39;post&#39;,
              title: &#39;Message Framing&#39;,
              series: &#39;TCP/IP .NET Sockets FAQ&#39;,
              seriesTitle: &#39;Message Framing&#39;,
              _content: &#39;## The Problem\n\nOne of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single &quot;Send&quot; will result in a single &quot;Receive&quot;.\n\nSome TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single &quot;Send&quot; does _not_ send a single _packet_.\n\nLocal machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single &quot;sends&quot; do in fact correspond to  single &quot;receives&quot;. Unfortunately, this is only a coincidence.\n\nThis problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!\n\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;\n&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;\n\nTrue story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to &quot;that buggy Windows OS&quot; or &quot;another network glitch&quot; and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.\n&lt;/div&gt;\n\n## The Solution, Part 1 - Understanding\n\nFirst, one must understand the abstraction of TCP/IP. From the application\&#39;s perspective, TCP operates on _streams_ of data, _never packets_. Repeat this mantra three times: &quot;TCP does not operate on _packets_ of data. TCP operates on _streams_ of data.&quot;\n\nThere is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a &quot;receive&quot; method, and one may write to the outgoing stream by calling a &quot;send&quot; method. If one side calls &quot;send&quot; to send 5 bytes, and then calls &quot;send&quot; to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling &quot;receive&quot; 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to &quot;receive&quot;.\n\nSending data to the TCP stream is rather easy; all one has to do is call &quot;send&quot;, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the &quot;receive N bytes&quot; operation will wait until _at least_ one byte and _at most_ N bytes arrive on the incoming stream before it returns. Note that the &quot;receive N bytes&quot; operation will complete even if it doesn\&#39;t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.\n\nTo repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of &quot;messages&quot;; for example, a client may send a &quot;Lookup X&quot; message to the server, and the server will respond with an &quot;X Data&quot; or &quot;X Not Found&quot; message. Since TCP operates on streams, one must design a &quot;message framing&quot; protocol that will wrap the messages sent back and forth.\n\n## The Solution, Part 2 - Design\n\nThere are two approaches commonly used for message framing: length prefixing and delimiters.\n\n**Length prefixing** prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; &quot;4-byte signed little-endian&quot; (i.e., &quot;int&quot; in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.\n\nReceiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using &quot;4-byte signed little-endian&quot;, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.\n\n**Delimiters** are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.\n\n## A Brief Security Note\n\nWhether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size &quot;sanity check&quot; in the socket reading code.\n\n## The Solution, Part 3 - Code\n\nA code sample for using length-prefixing is in its own blog post at [http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html]({% post_url 2009-04-30-sample-code-length-prefix-message %}).\n\nAnother decent code example of length prefixing is on [Jon Cole\&#39;s blog](http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx), although he assumes all the messages are just ASCII strings.\n\nYet another example of length prefixing is in the [Nito.Async](http://www.codeplex.com/NitoAsync) library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.\n\n&#39;,
              source: &#39;_posts/2009-04-30-message-framing.md&#39;,
              raw: &#39;---\nlayout: post\ntitle: &quot;Message Framing&quot;\nseries: &quot;TCP/IP .NET Sockets FAQ&quot;\nseriesTitle: &quot;Message Framing&quot;\n---\n## The Problem\n\nOne of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single &quot;Send&quot; will result in a single &quot;Receive&quot;.\n\nSome TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single &quot;Send&quot; does _not_ send a single _packet_.\n\nLocal machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single &quot;sends&quot; do in fact correspond to  single &quot;receives&quot;. Unfortunately, this is only a coincidence.\n\nThis problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!\n\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;\n&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;\n\nTrue story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to &quot;that buggy Windows OS&quot; or &quot;another network glitch&quot; and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.\n&lt;/div&gt;\n\n## The Solution, Part 1 - Understanding\n\nFirst, one must understand the abstraction of TCP/IP. From the application\&#39;s perspective, TCP operates on _streams_ of data, _never packets_. Repeat this mantra three times: &quot;TCP does not operate on _packets_ of data. TCP operates on _streams_ of data.&quot;\n\nThere is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a &quot;receive&quot; method, and one may write to the outgoing stream by calling a &quot;send&quot; method. If one side calls &quot;send&quot; to send 5 bytes, and then calls &quot;send&quot; to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling &quot;receive&quot; 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to &quot;receive&quot;.\n\nSending data to the TCP stream is rather easy; all one has to do is call &quot;send&quot;, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the &quot;receive N bytes&quot; operation will wait until _at least_ one byte and _at most_ N bytes arrive on the incoming stream before it returns. Note that the &quot;receive N bytes&quot; operation will complete even if it doesn\&#39;t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.\n\nTo repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of &quot;messages&quot;; for example, a client may send a &quot;Lookup X&quot; message to the server, and the server will respond with an &quot;X Data&quot; or &quot;X Not Found&quot; message. Since TCP operates on streams, one must design a &quot;message framing&quot; protocol that will wrap the messages sent back and forth.\n\n## The Solution, Part 2 - Design\n\nThere are two approaches commonly used for message framing: length prefixing and delimiters.\n\n**Length prefixing** prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; &quot;4-byte signed little-endian&quot; (i.e., &quot;int&quot; in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.\n\nReceiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using &quot;4-byte signed little-endian&quot;, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.\n\n**Delimiters** are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.\n\n## A Brief Security Note\n\nWhether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size &quot;sanity check&quot; in the socket reading code.\n\n## The Solution, Part 3 - Code\n\nA code sample for using length-prefixing is in its own blog post at [http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html]({% post_url 2009-04-30-sample-code-length-prefix-message %}).\n\nAnother decent code example of length prefixing is on [Jon Cole\&#39;s blog](http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx), although he assumes all the messages are just ASCII strings.\n\nYet another example of length prefixing is in the [Nito.Async](http://www.codeplex.com/NitoAsync) library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.\n\n&#39;,
              slug: &#39;message-framing&#39;,
              published: true,
              date: 
               { [Number: 1241064000000]
                 _isAMomentObject: true,
                 _i: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
                 _isUTC: false,
                 _locale: 
                  { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: [Function],
                    _abbr: &#39;en&#39;,
                    _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                 _d: Thu Apr 30 2009 00:00:00 GMT-0400 (Eastern Daylight Time),
                 _z: null,
                 _pf: 
                  { empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false },
                 _isValid: true },
              updated: 
               { [Number: 1400778787476]
                 _isAMomentObject: true,
                 _i: Thu May 22 2014 13:13:07 GMT-0400 (Eastern Daylight Time),
                 _isUTC: false,
                 _locale: 
                  { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: [Function],
                    _abbr: &#39;en&#39;,
                    _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                 _d: Thu May 22 2014 13:13:07 GMT-0400 (Eastern Daylight Time),
                 _z: null },
              comments: true,
              photos: [],
              link: &#39;&#39;,
              _id: &#39;cie5tulna0005xoryq80g0aac&#39;,
              content: &#39;&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;One of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single “Send” will result in a single “Receive”.&lt;/p&gt;\n&lt;p&gt;Some TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single “Send” does &lt;em&gt;not&lt;/em&gt; send a single &lt;em&gt;packet&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Local machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single “sends” do in fact correspond to  single “receives”. Unfortunately, this is only a coincidence.&lt;/p&gt;\n&lt;p&gt;This problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!&lt;/p&gt;\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;&lt;br&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;True story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to “that buggy Windows OS” or “another network glitch” and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.&lt;br&gt;&lt;/div&gt;\n\n&lt;h2 id=&quot;The_Solution,_Part_1_-_Understanding&quot;&gt;The Solution, Part 1 - Understanding&lt;/h2&gt;&lt;p&gt;First, one must understand the abstraction of TCP/IP. From the application’s perspective, TCP operates on &lt;em&gt;streams&lt;/em&gt; of data, &lt;em&gt;never packets&lt;/em&gt;. Repeat this mantra three times: “TCP does not operate on &lt;em&gt;packets&lt;/em&gt; of data. TCP operates on &lt;em&gt;streams&lt;/em&gt; of data.”&lt;/p&gt;\n&lt;p&gt;There is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a “receive” method, and one may write to the outgoing stream by calling a “send” method. If one side calls “send” to send 5 bytes, and then calls “send” to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling “receive” 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to “receive”.&lt;/p&gt;\n&lt;p&gt;Sending data to the TCP stream is rather easy; all one has to do is call “send”, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the “receive N bytes” operation will wait until &lt;em&gt;at least&lt;/em&gt; one byte and &lt;em&gt;at most&lt;/em&gt; N bytes arrive on the incoming stream before it returns. Note that the “receive N bytes” operation will complete even if it doesn’t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.&lt;/p&gt;\n&lt;p&gt;To repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of “messages”; for example, a client may send a “Lookup X” message to the server, and the server will respond with an “X Data” or “X Not Found” message. Since TCP operates on streams, one must design a “message framing” protocol that will wrap the messages sent back and forth.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_2_-_Design&quot;&gt;The Solution, Part 2 - Design&lt;/h2&gt;&lt;p&gt;There are two approaches commonly used for message framing: length prefixing and delimiters.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Length prefixing&lt;/strong&gt; prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; “4-byte signed little-endian” (i.e., “int” in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.&lt;/p&gt;\n&lt;p&gt;Receiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using “4-byte signed little-endian”, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Delimiters&lt;/strong&gt; are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.&lt;/p&gt;\n&lt;h2 id=&quot;A_Brief_Security_Note&quot;&gt;A Brief Security Note&lt;/h2&gt;&lt;p&gt;Whether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size “sanity check” in the socket reading code.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_3_-_Code&quot;&gt;The Solution, Part 3 - Code&lt;/h2&gt;&lt;p&gt;A code sample for using length-prefixing is in its own blog post at &lt;a href=&quot;!--￼0--&quot;&gt;http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Another decent code example of length prefixing is on &lt;a href=&quot;http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx&quot;&gt;Jon Cole’s blog&lt;/a&gt;, although he assumes all the messages are just ASCII strings.&lt;/p&gt;\n&lt;p&gt;Yet another example of length prefixing is in the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.&lt;/p&gt;\n&#39;,
              excerpt: &#39;&#39;,
              more: &#39;&lt;h2 id=&quot;The_Problem&quot;&gt;The Problem&lt;/h2&gt;&lt;p&gt;One of the most common beginner mistakes for people designing protocols for TCP/IP is that they assume that message boundaries are preserved. For example, they assume a single “Send” will result in a single “Receive”.&lt;/p&gt;\n&lt;p&gt;Some TCP/IP documentation is partially to blame. Many people read about how TCP/IP preserves packets - splitting them up when necessary and re-ordering and re-assembling them on the receiving side. This is perfectly true; however, a single “Send” does &lt;em&gt;not&lt;/em&gt; send a single &lt;em&gt;packet&lt;/em&gt;.&lt;/p&gt;\n&lt;p&gt;Local machine (loopback) testing confirms this misunderstanding, because usually when client and server are on the same machine they communicate quickly enough that single “sends” do in fact correspond to  single “receives”. Unfortunately, this is only a coincidence.&lt;/p&gt;\n&lt;p&gt;This problem usually manifests itself when attempting to deploy a solution to the Internet (increasing latency between client and server) or when trying to send larger amounts of data (requiring fragmentation). Unfortunately, at this point, the project is usually in its final stages, and sometimes the application protocol has even been published!&lt;/p&gt;\n&lt;div class=&quot;alert alert-info&quot; markdown=&quot;1&quot;&gt;&lt;br&gt;&lt;i class=&quot;fa fa-hand-o-right fa-2x pull-left&quot;&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt;True story: I once worked for a company that developed custom client/server software. The original communications code had made this common mistake. However, they were all on dedicated networks with high-end hardware, so the underlying problem only happened very rarely. When it did, the operators would just chalk it up to “that buggy Windows OS” or “another network glitch” and reboot. One of my tasks at this company was to change the communication to include a lot more information; of course, this caused the problem to manifest regularly, and the entire application protocol had to be changed to fix it. The truly amazing thing is that this software had been used in countless 24x7 automation systems for 20 years; it was fundamentally broken and no one noticed.&lt;br&gt;&lt;/div&gt;\n\n&lt;h2 id=&quot;The_Solution,_Part_1_-_Understanding&quot;&gt;The Solution, Part 1 - Understanding&lt;/h2&gt;&lt;p&gt;First, one must understand the abstraction of TCP/IP. From the application’s perspective, TCP operates on &lt;em&gt;streams&lt;/em&gt; of data, &lt;em&gt;never packets&lt;/em&gt;. Repeat this mantra three times: “TCP does not operate on &lt;em&gt;packets&lt;/em&gt; of data. TCP operates on &lt;em&gt;streams&lt;/em&gt; of data.”&lt;/p&gt;\n&lt;p&gt;There is no way to send a packet of data over TCP; that function call does not exist. Rather, there are two streams in a TCP connection: an incoming stream and an outgoing stream. One may read from the incoming stream by calling a “receive” method, and one may write to the outgoing stream by calling a “send” method. If one side calls “send” to send 5 bytes, and then calls “send” to send 5 more bytes, then there are 10 bytes that are placed in the outgoing stream. The receiving side may decide to read them one at a time from its receiving stream if it so wishes (calling “receive” 10 times), or it may wait for all 10 bytes to arrive and then read them all at once with a single call to “receive”.&lt;/p&gt;\n&lt;p&gt;Sending data to the TCP stream is rather easy; all one has to do is call “send”, and the appropriate bytes are queued to the outgoing stream. Receiving data from the TCP stream is a bit more tricky, because the “receive N bytes” operation will wait until &lt;em&gt;at least&lt;/em&gt; one byte and &lt;em&gt;at most&lt;/em&gt; N bytes arrive on the incoming stream before it returns. Note that the “receive N bytes” operation will complete even if it doesn’t read all N bytes, giving the application a chance to act on partial data while the rest of the data bytes are in transit. In the real world, very few programs can process partial receives; almost all programs need a buffer to store partial receives until they have enough data to do meaningful work.&lt;/p&gt;\n&lt;p&gt;To repeat: TCP operates on streams, not on packets. However, most application protocols are based on the idea of “messages”; for example, a client may send a “Lookup X” message to the server, and the server will respond with an “X Data” or “X Not Found” message. Since TCP operates on streams, one must design a “message framing” protocol that will wrap the messages sent back and forth.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_2_-_Design&quot;&gt;The Solution, Part 2 - Design&lt;/h2&gt;&lt;p&gt;There are two approaches commonly used for message framing: length prefixing and delimiters.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Length prefixing&lt;/strong&gt; prepends each message with the length of that message. The format (and length) of the length prefix must be explicitly stated; “4-byte signed little-endian” (i.e., “int” in C#) is a common choice. To send a message, the sending side first converts the message to a byte array and then sends the length of the byte array followed by the byte array itself.&lt;/p&gt;\n&lt;p&gt;Receiving a length-prefixed message is harder, because of the possibility of partial receives. First, one must read the length of the message into a buffer until the buffer is full (e.g., if using “4-byte signed little-endian”, this buffer is 4 bytes). Then one allocates a second buffer and reads the data into that buffer. When the second buffer is full, then a single message has arrived, and one goes back to reading the length of the next message.&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Delimiters&lt;/strong&gt; are more complex to get right. When sending, any delimiter characters in the data must be replaced, usually with an escaping function. The receiving code cannot predict the incoming message size, so it must append all received data onto the end of a receiving buffer, growing the buffer as necessary. When a delimiter is found, the receiving side can apply an unescaping function to the receiving buffer to get the message. If the messages will never contain delimiters, then one may skip the escaping/unescaping functions.&lt;/p&gt;\n&lt;h2 id=&quot;A_Brief_Security_Note&quot;&gt;A Brief Security Note&lt;/h2&gt;&lt;p&gt;Whether using length-prefixing or delimiters, one must include code to prevent denial of service attacks. Length-prefixed readers can be given a huge message size; delimiting readers can be given a huge amount of data without delimiters. Either of these may result in an OutOfMemoryException, so one must include a maximum message size “sanity check” in the socket reading code.&lt;/p&gt;\n&lt;h2 id=&quot;The_Solution,_Part_3_-_Code&quot;&gt;The Solution, Part 3 - Code&lt;/h2&gt;&lt;p&gt;A code sample for using length-prefixing is in its own blog post at &lt;a href=&quot;!--￼0--&quot;&gt;http://blog.stephencleary.com/2009/04/sample-code-length-prefix-message.html&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Another decent code example of length prefixing is on &lt;a href=&quot;http://blogs.msdn.com/joncole/archive/2006/04/25/simple-message-framing-sample-for-tcp-socket-part-2-asynchronous.aspx&quot;&gt;Jon Cole’s blog&lt;/a&gt;, although he assumes all the messages are just ASCII strings.&lt;/p&gt;\n&lt;p&gt;Yet another example of length prefixing is in the &lt;a href=&quot;http://www.codeplex.com/NitoAsync&quot;&gt;Nito.Async&lt;/a&gt; library: the Nito.Async.Sockets.SocketPacketProtocol class can be used to send or receive length-prefixed binary messages. It is written to use the Nito.Async socket classes, but the same code concepts translate well to the .NET Socket class.&lt;/p&gt;\n&#39;,
              path: [Getter],
              permalink: [Getter],
              full_source: [Getter],
              asset_dir: [Getter],
              tags: [Getter],
              categories: [Getter],
              next: [Circular] },
           next: [Circular] },
        next: [Circular] },
     next: 
      { layout: &#39;post&#39;,
        title: &#39;IDisposable article published&#39;,
        _content: &#39;Today I published my first article on CodeProject: [IDisposable: What Your Mother Never Told You About Resource Deallocation](http://www.codeproject.com/KB/dotnet/IDisposable.aspx). It\&#39;s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft\&#39;s recommended IDisposable code pattern.\n\n&#39;,
        source: &#39;_posts/2008-09-21-idisposable-article-published.md&#39;,
        raw: &#39;---\nlayout: post\ntitle: &quot;IDisposable article published&quot;\n---\nToday I published my first article on CodeProject: [IDisposable: What Your Mother Never Told You About Resource Deallocation](http://www.codeproject.com/KB/dotnet/IDisposable.aspx). It\&#39;s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft\&#39;s recommended IDisposable code pattern.\n\n&#39;,
        slug: &#39;idisposable-article-published&#39;,
        published: true,
        date: 
         { [Number: 1221969600000]
           _isAMomentObject: true,
           _i: Sun Sep 21 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Sun Sep 21 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
           _z: null,
           _pf: 
            { empty: false,
              unusedTokens: [],
              unusedInput: [],
              overflow: -2,
              charsLeftOver: 0,
              nullInput: false,
              invalidMonth: null,
              invalidFormat: false,
              userInvalidated: false,
              iso: false },
           _isValid: true },
        updated: 
         { [Number: 1400776290627]
           _isAMomentObject: true,
           _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
           _isUTC: false,
           _locale: 
            { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
              ordinal: [Function],
              _abbr: &#39;en&#39;,
              _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
           _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
           _z: null },
        comments: true,
        photos: [],
        link: &#39;&#39;,
        _id: &#39;cie5tuln30002xorylmgv553t&#39;,
        content: &#39;&lt;p&gt;Today I published my first article on CodeProject: &lt;a href=&quot;http://www.codeproject.com/KB/dotnet/IDisposable.aspx&quot;&gt;IDisposable: What Your Mother Never Told You About Resource Deallocation&lt;/a&gt;. It’s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft’s recommended IDisposable code pattern.&lt;/p&gt;\n&#39;,
        excerpt: &#39;&#39;,
        more: &#39;&lt;p&gt;Today I published my first article on CodeProject: &lt;a href=&quot;http://www.codeproject.com/KB/dotnet/IDisposable.aspx&quot;&gt;IDisposable: What Your Mother Never Told You About Resource Deallocation&lt;/a&gt;. It’s a description of the problems with IDisposable and introduces the Disposable Design Principle as a better alternative to Microsoft’s recommended IDisposable code pattern.&lt;/p&gt;\n&#39;,
        path: [Getter],
        permalink: [Getter],
        full_source: [Getter],
        asset_dir: [Getter],
        tags: [Getter],
        categories: [Getter],
        prev: [Circular],
        next: 
         { layout: &#39;post&#39;,
           title: &#39;OpenSSL 0.9.8i Binaries&#39;,
           _content: &#39;We built the OpenSSL binaries for Windows, and made them publicly available at [http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670](http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670)\n\nNote that there are a few differences for our version, compared to other binary packages:\n\n- All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).\n- No static libraries are built; these are all DLLs.\n- Include directories and HTML documentation are packaged as well, but no import libraries.\n- No executables are included (e.g., openssl.exe).\n- The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.\n- An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.\n\n&#39;,
           source: &#39;_posts/2008-09-16-openssl-098i-binaries.md&#39;,
           raw: &#39;---\nlayout: post\ntitle: &quot;OpenSSL 0.9.8i Binaries&quot;\n---\nWe built the OpenSSL binaries for Windows, and made them publicly available at [http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670](http://sourceforge.net/project/showfiles.php?group_id=26202&amp;package_id=291670)\n\nNote that there are a few differences for our version, compared to other binary packages:\n\n- All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).\n- No static libraries are built; these are all DLLs.\n- Include directories and HTML documentation are packaged as well, but no import libraries.\n- No executables are included (e.g., openssl.exe).\n- The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.\n- An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.\n\n&#39;,
           slug: &#39;openssl-098i-binaries&#39;,
           published: true,
           date: 
            { [Number: 1221537600000]
              _isAMomentObject: true,
              _i: Tue Sep 16 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
              _isUTC: false,
              _locale: 
               { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                 ordinal: [Function],
                 _abbr: &#39;en&#39;,
                 _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
              _d: Tue Sep 16 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
              _z: null,
              _pf: 
               { empty: false,
                 unusedTokens: [],
                 unusedInput: [],
                 overflow: -2,
                 charsLeftOver: 0,
                 nullInput: false,
                 invalidMonth: null,
                 invalidFormat: false,
                 userInvalidated: false,
                 iso: false },
              _isValid: true },
           updated: 
            { [Number: 1400901755274]
              _isAMomentObject: true,
              _i: Fri May 23 2014 23:22:35 GMT-0400 (Eastern Daylight Time),
              _isUTC: false,
              _locale: 
               { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                 ordinal: [Function],
                 _abbr: &#39;en&#39;,
                 _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
              _d: Fri May 23 2014 23:22:35 GMT-0400 (Eastern Daylight Time),
              _z: null },
           comments: true,
           photos: [],
           link: &#39;&#39;,
           _id: &#39;cie5tuln50003xoryyij63lqy&#39;,
           content: &#39;&lt;p&gt;We built the OpenSSL binaries for Windows, and made them publicly available at &lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&quot;&gt;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Note that there are a few differences for our version, compared to other binary packages:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).&lt;/li&gt;\n&lt;li&gt;No static libraries are built; these are all DLLs.&lt;/li&gt;\n&lt;li&gt;Include directories and HTML documentation are packaged as well, but no import libraries.&lt;/li&gt;\n&lt;li&gt;No executables are included (e.g., openssl.exe).&lt;/li&gt;\n&lt;li&gt;The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;li&gt;An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
           excerpt: &#39;&#39;,
           more: &#39;&lt;p&gt;We built the OpenSSL binaries for Windows, and made them publicly available at &lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&quot;&gt;http://sourceforge.net/project/showfiles.php?group_id=26202&amp;amp;package_id=291670&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Note that there are a few differences for our version, compared to other binary packages:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;All patent-encumbered algorithms have been removed (e.g., IDEA, RC5, etc.).&lt;/li&gt;\n&lt;li&gt;No static libraries are built; these are all DLLs.&lt;/li&gt;\n&lt;li&gt;Include directories and HTML documentation are packaged as well, but no import libraries.&lt;/li&gt;\n&lt;li&gt;No executables are included (e.g., openssl.exe).&lt;/li&gt;\n&lt;li&gt;The x86 DLL does not have any dependency on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;li&gt;An x64 (AMD64) version of the DLLs are also included, though they do depend on the Microsoft Visual C++ Runtime Redistributables.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
           path: [Getter],
           permalink: [Getter],
           full_source: [Getter],
           asset_dir: [Getter],
           tags: [Getter],
           categories: [Getter],
           prev: [Circular],
           next: 
            { layout: &#39;post&#39;,
              title: &#39;Interop documentation pointers&#39;,
              _content: &#39;To become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here\&#39;s an attempt to bring it together, as a &quot;C++ .NET interop quick reference&quot;:\n\n- [Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke](http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx) - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages](http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx) - Details how to get C#-like behavior in C++.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR](http://msdn.microsoft.com/en-us/library/xey702bw.aspx) - Reference information for cli::pin_ptr, cli::array, managed enums, etc.\n- [.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class](http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx) - A BCL type that defines some very useful functions such as PtrToString* and StringTo*.\n\n&#39;,
              source: &#39;_posts/2008-07-24-interop-documentation-pointers.md&#39;,
              raw: &#39;---\nlayout: post\ntitle: &quot;Interop documentation pointers&quot;\n---\nTo become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here\&#39;s an attempt to bring it together, as a &quot;C++ .NET interop quick reference&quot;:\n\n- [Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke](http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx) - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages](http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx) - Details how to get C#-like behavior in C++.\n- [Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR](http://msdn.microsoft.com/en-us/library/xey702bw.aspx) - Reference information for cli::pin_ptr, cli::array, managed enums, etc.\n- [.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class](http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx) - A BCL type that defines some very useful functions such as PtrToString* and StringTo*.\n\n&#39;,
              slug: &#39;interop-documentation-pointers&#39;,
              published: true,
              date: 
               { [Number: 1216872000000]
                 _isAMomentObject: true,
                 _i: Thu Jul 24 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                 _isUTC: false,
                 _locale: 
                  { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: [Function],
                    _abbr: &#39;en&#39;,
                    _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                 _d: Thu Jul 24 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                 _z: null,
                 _pf: 
                  { empty: false,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: false,
                    invalidMonth: null,
                    invalidFormat: false,
                    userInvalidated: false,
                    iso: false },
                 _isValid: true },
              updated: 
               { [Number: 1400776290604]
                 _isAMomentObject: true,
                 _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                 _isUTC: false,
                 _locale: 
                  { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                    ordinal: [Function],
                    _abbr: &#39;en&#39;,
                    _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                 _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                 _z: null },
              comments: true,
              photos: [],
              link: &#39;&#39;,
              _id: &#39;cie5tulnc0006xory6w6m8p2h&#39;,
              content: &#39;&lt;p&gt;To become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here’s an attempt to bring it together, as a “C++ .NET interop quick reference”:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke&lt;/a&gt; - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages&lt;/a&gt; - Details how to get C#-like behavior in C++.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xey702bw.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR&lt;/a&gt; - Reference information for cli::pin_ptr, cli::array, managed enums, etc.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx&quot;&gt;.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class&lt;/a&gt; - A BCL type that defines some very useful functions such as PtrToString&lt;em&gt; and StringTo&lt;/em&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
              excerpt: &#39;&#39;,
              more: &#39;&lt;p&gt;To become really proficient at good interop code, one must master a range of skills. The MSDN documentation is rather spread out regarding this, so here’s an attempt to bring it together, as a “C++ .NET interop quick reference”:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/fzhhdwae.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: .NET Framework Programming in Visual Studio :: .NET Framework Advanced Development :: Interoperability :: Interoperating with Unmanaged Code :: Interop Marshaling :: Marshaling Data with Platform Invoke&lt;/a&gt; - Gives a good overview of how to marshal the actual data to and from unmanaged code. Particularly useful when dealing with arrays and strings.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/s1kw2y09.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: .NET Programming Guide :: Interoperability with Other .NET Languages&lt;/a&gt; - Details how to get C#-like behavior in C++.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xey702bw.aspx&quot;&gt;Development Tools and Languages :: Visual Studio :: Visual C++ :: Reference :: C/C++ Languages :: C++ Language Reference :: Language Features for Targeting the CLR&lt;/a&gt; - Reference information for cli::pin_ptr, cli::array, managed enums, etc.&lt;/li&gt;\n&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal.aspx&quot;&gt;.NET Development :: .NET Framework SDK :: .NET Framework :: .NET Framework Class Library :: System.Runtime.InteropServices Namespace :: Marshal Class&lt;/a&gt; - A BCL type that defines some very useful functions such as PtrToString&lt;em&gt; and StringTo&lt;/em&gt;.&lt;/li&gt;\n&lt;/ul&gt;\n&#39;,
              path: [Getter],
              permalink: [Getter],
              full_source: [Getter],
              asset_dir: [Getter],
              tags: [Getter],
              categories: [Getter],
              prev: [Circular],
              next: 
               { layout: &#39;post&#39;,
                 title: &#39;Software-only device drivers: What\&#39;s in a name?&#39;,
                 _content: &#39;There\&#39;s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:\n\n- Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive\n- Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).\n- Virtual keyboards and mice are often used by gamepad systems\n- Virtual serial ports are used for testing or running serial programs on laptops\n- Virtual hard drives can be used as encrypted volumes\n- Other virtual devices are often developed by companies for testing purposes\n\nThe examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.\n\nThere have been a few different names tossed around to describe these drivers without hardware:\n\n - &quot;Virtual device drivers&quot; - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD\&#39;s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward &quot;virtual device driver&quot; should not be used for drivers without hardware because of the possibility of this confusion.\n - &quot;Software device drivers&quot; - this term could refer to any device driver, because they are all software. The term &quot;software device driver&quot; is in fact regularly used in this fashion, especially by those who work more with hardware.\n\nThis leaves us with the unambiguous but rather unweildly terms &quot;device driver without hardware&quot;, &quot;hardwareless device driver&quot;, or &quot;software-only device driver&quot;. Of these, the term &quot;software-only device driver&quot; seems to be getting some gradual [acceptance](http://www.google.com/search?q=%22software-only%22+device+driver) by the driver-writing community.\n\n&#39;,
                 source: &#39;_posts/2008-07-11-software-only-device-drivers-whats-in.md&#39;,
                 raw: &#39;---\nlayout: post\ntitle: &quot;Software-only device drivers: What\&#39;s in a name?&quot;\n---\nThere\&#39;s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:\n\n- Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive\n- Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).\n- Virtual keyboards and mice are often used by gamepad systems\n- Virtual serial ports are used for testing or running serial programs on laptops\n- Virtual hard drives can be used as encrypted volumes\n- Other virtual devices are often developed by companies for testing purposes\n\nThe examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.\n\nThere have been a few different names tossed around to describe these drivers without hardware:\n\n - &quot;Virtual device drivers&quot; - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD\&#39;s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward &quot;virtual device driver&quot; should not be used for drivers without hardware because of the possibility of this confusion.\n - &quot;Software device drivers&quot; - this term could refer to any device driver, because they are all software. The term &quot;software device driver&quot; is in fact regularly used in this fashion, especially by those who work more with hardware.\n\nThis leaves us with the unambiguous but rather unweildly terms &quot;device driver without hardware&quot;, &quot;hardwareless device driver&quot;, or &quot;software-only device driver&quot;. Of these, the term &quot;software-only device driver&quot; seems to be getting some gradual [acceptance](http://www.google.com/search?q=%22software-only%22+device+driver) by the driver-writing community.\n\n&#39;,
                 slug: &#39;software-only-device-drivers-whats-in&#39;,
                 published: true,
                 date: 
                  { [Number: 1215748800000]
                    _isAMomentObject: true,
                    _i: Fri Jul 11 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                    _isUTC: false,
                    _locale: 
                     { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                       ordinal: [Function],
                       _abbr: &#39;en&#39;,
                       _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                    _d: Fri Jul 11 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                    _z: null,
                    _pf: 
                     { empty: false,
                       unusedTokens: [],
                       unusedInput: [],
                       overflow: -2,
                       charsLeftOver: 0,
                       nullInput: false,
                       invalidMonth: null,
                       invalidFormat: false,
                       userInvalidated: false,
                       iso: false },
                    _isValid: true },
                 updated: 
                  { [Number: 1400776290520]
                    _isAMomentObject: true,
                    _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                    _isUTC: false,
                    _locale: 
                     { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                       ordinal: [Function],
                       _abbr: &#39;en&#39;,
                       _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                    _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                    _z: null },
                 comments: true,
                 photos: [],
                 link: &#39;&#39;,
                 _id: &#39;cie5tulmw0000xoryzylgfjrr&#39;,
                 content: &#39;&lt;p&gt;There’s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive&lt;/li&gt;\n&lt;li&gt;Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).&lt;/li&gt;\n&lt;li&gt;Virtual keyboards and mice are often used by gamepad systems&lt;/li&gt;\n&lt;li&gt;Virtual serial ports are used for testing or running serial programs on laptops&lt;/li&gt;\n&lt;li&gt;Virtual hard drives can be used as encrypted volumes&lt;/li&gt;\n&lt;li&gt;Other virtual devices are often developed by companies for testing purposes&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.&lt;/p&gt;\n&lt;p&gt;There have been a few different names tossed around to describe these drivers without hardware:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;“Virtual device drivers” - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD’s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward “virtual device driver” should not be used for drivers without hardware because of the possibility of this confusion.&lt;/li&gt;\n&lt;li&gt;“Software device drivers” - this term could refer to any device driver, because they are all software. The term “software device driver” is in fact regularly used in this fashion, especially by those who work more with hardware.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This leaves us with the unambiguous but rather unweildly terms “device driver without hardware”, “hardwareless device driver”, or “software-only device driver”. Of these, the term “software-only device driver” seems to be getting some gradual &lt;a href=&quot;http://www.google.com/search?q=%22software-only%22+device+driver&quot;&gt;acceptance&lt;/a&gt; by the driver-writing community.&lt;/p&gt;\n&#39;,
                 excerpt: &#39;&#39;,
                 more: &#39;&lt;p&gt;There’s currently no consensus on the terminology used to refer to device drivers that do not have hardware. These types of drivers are quite useful in many scenarios:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Virtual CD-ROM drives can mount a CD image from your hard drive and pretend it was put in a CD-ROM drive&lt;/li&gt;\n&lt;li&gt;Virtual network cards are used by somme VPN products like OpenVPN (as well as virtual machine systems like VMWare Workstation) to enable special netowrk communications (e.g., over a VPN or to a virtual machine).&lt;/li&gt;\n&lt;li&gt;Virtual keyboards and mice are often used by gamepad systems&lt;/li&gt;\n&lt;li&gt;Virtual serial ports are used for testing or running serial programs on laptops&lt;/li&gt;\n&lt;li&gt;Virtual hard drives can be used as encrypted volumes&lt;/li&gt;\n&lt;li&gt;Other virtual devices are often developed by companies for testing purposes&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;The examples above are all drivers for virtual hardware. There is another class of drivers without hardware: monitor drivers, which attach to drivers for real (or virtual) hardware and observe (and/or change) the data going in and out of that driver. This is how programs like FileSpy and Process Monitor work. Finally, some drivers simply do not have anything to do with any hardware at all, real or virtual.&lt;/p&gt;\n&lt;p&gt;There have been a few different names tossed around to describe these drivers without hardware:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;“Virtual device drivers” - unfortunately, this has another meaning in the Windows world. Virtual device drivers (VxD’s) were used in the 9x systems to help DOS programs run by sharing hardware - a virtual device was presented to each DOS program, which believed it had full access to the deivce, and the VxD would take care of managing the sharing of the device. Driver developers generall agree that the straightforward “virtual device driver” should not be used for drivers without hardware because of the possibility of this confusion.&lt;/li&gt;\n&lt;li&gt;“Software device drivers” - this term could refer to any device driver, because they are all software. The term “software device driver” is in fact regularly used in this fashion, especially by those who work more with hardware.&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;This leaves us with the unambiguous but rather unweildly terms “device driver without hardware”, “hardwareless device driver”, or “software-only device driver”. Of these, the term “software-only device driver” seems to be getting some gradual &lt;a href=&quot;http://www.google.com/search?q=%22software-only%22+device+driver&quot;&gt;acceptance&lt;/a&gt; by the driver-writing community.&lt;/p&gt;\n&#39;,
                 path: [Getter],
                 permalink: [Getter],
                 full_source: [Getter],
                 asset_dir: [Getter],
                 tags: [Getter],
                 categories: [Getter],
                 prev: [Circular],
                 next: 
                  { layout: &#39;post&#39;,
                    title: &#39;Soyo widescreen monitor inf available&#39;,
                    _content: &#39;This isn\&#39;t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24&quot;; this .inf file fixes two common problems:\n1. Users cannot select the native 1920x1200 resolution\n1. Games fail with a &quot;Signal out of range&quot; error\n\nLike many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a [Soyo Topaz S 24&quot; widescreen monitor](http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408)... nice.\n\nHowever, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo\&#39;s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.\n\nA lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows\&#39; restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn\&#39;t support.\n\nI was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous &quot;Signal out of range&quot; monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor\&#39;s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)\n\nSo, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor... since they weren\&#39;t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.\n\nI decided to release this little utility for free [on SourceForge](https://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=283420). This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I\&#39;ve only thoroughly tested it on Vista x64.\n\nTo install it, just right-click on the &quot;Generic Non-PnP Monitor&quot; in the Device Manager, update the drivers, and select the inf file.\n\n[![]({{ site_url }}/assets/Step+1.png)]({{ site_url }}/assets/Step+1.png)\n\nRight-click the &quot;Generic Non-PnP Monitor&quot; and select &quot;Update Driver Software...&quot;\n\n[![]({{ site_url }}/assets/Step+2.png)]({{ site_url }}/assets/Step+2.png)\n\nChoose &quot;Browse my computer for driver software&quot;\n\n[![]({{ site_url }}/assets/Step+3.png)]({{ site_url }}/assets/Step+3.png)\n\nChoose &quot;Let me pick from a list of device drivers on my computer&quot;\n\n[![]({{ site_url }}/assets/Step+4.png)]({{ site_url }}/assets/Step+4.png)\n\nClick &quot;Have Disk...&quot;\n\n[![]({{ site_url }}/assets/Step+5.png)]({{ site_url }}/assets/Step+5.png)\n\nClick &quot;Browse...&quot;\n\n[![]({{ site_url }}/assets/Step+6.png)]({{ site_url }}/assets/Step+6.png)\n\nSelect the Soyo.inf that was downloaded from SourceForge.net\n\n[![]({{ site_url }}/assets/Step+7.png)]({{ site_url }}/assets/Step+7.png)\n\nClick &quot;Next&quot;\n\n[![]({{ site_url }}/assets/Step+8.png)]({{ site_url }}/assets/Step+8.png)\n\nConfirm security question\n\nEnjoy!&#39;,
                    source: &#39;_posts/2008-07-08-soyo-widescreen-monitor-inf-available.md&#39;,
                    raw: &#39;---\nlayout: post\ntitle: &quot;Soyo widescreen monitor inf available&quot;\n---\nThis isn\&#39;t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24&quot;; this .inf file fixes two common problems:\n1. Users cannot select the native 1920x1200 resolution\n1. Games fail with a &quot;Signal out of range&quot; error\n\nLike many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a [Soyo Topaz S 24&quot; widescreen monitor](http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408)... nice.\n\nHowever, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo\&#39;s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.\n\nA lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows\&#39; restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn\&#39;t support.\n\nI was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous &quot;Signal out of range&quot; monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor\&#39;s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)\n\nSo, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor... since they weren\&#39;t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.\n\nI decided to release this little utility for free [on SourceForge](https://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=283420). This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I\&#39;ve only thoroughly tested it on Vista x64.\n\nTo install it, just right-click on the &quot;Generic Non-PnP Monitor&quot; in the Device Manager, update the drivers, and select the inf file.\n\n[![]({{ site_url }}/assets/Step+1.png)]({{ site_url }}/assets/Step+1.png)\n\nRight-click the &quot;Generic Non-PnP Monitor&quot; and select &quot;Update Driver Software...&quot;\n\n[![]({{ site_url }}/assets/Step+2.png)]({{ site_url }}/assets/Step+2.png)\n\nChoose &quot;Browse my computer for driver software&quot;\n\n[![]({{ site_url }}/assets/Step+3.png)]({{ site_url }}/assets/Step+3.png)\n\nChoose &quot;Let me pick from a list of device drivers on my computer&quot;\n\n[![]({{ site_url }}/assets/Step+4.png)]({{ site_url }}/assets/Step+4.png)\n\nClick &quot;Have Disk...&quot;\n\n[![]({{ site_url }}/assets/Step+5.png)]({{ site_url }}/assets/Step+5.png)\n\nClick &quot;Browse...&quot;\n\n[![]({{ site_url }}/assets/Step+6.png)]({{ site_url }}/assets/Step+6.png)\n\nSelect the Soyo.inf that was downloaded from SourceForge.net\n\n[![]({{ site_url }}/assets/Step+7.png)]({{ site_url }}/assets/Step+7.png)\n\nClick &quot;Next&quot;\n\n[![]({{ site_url }}/assets/Step+8.png)]({{ site_url }}/assets/Step+8.png)\n\nConfirm security question\n\nEnjoy!&#39;,
                    slug: &#39;soyo-widescreen-monitor-inf-available&#39;,
                    published: true,
                    date: 
                     { [Number: 1215489600000]
                       _isAMomentObject: true,
                       _i: Tue Jul 08 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                       _isUTC: false,
                       _locale: 
                        { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                          ordinal: [Function],
                          _abbr: &#39;en&#39;,
                          _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                       _d: Tue Jul 08 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                       _z: null,
                       _pf: 
                        { empty: false,
                          unusedTokens: [],
                          unusedInput: [],
                          overflow: -2,
                          charsLeftOver: 0,
                          nullInput: false,
                          invalidMonth: null,
                          invalidFormat: false,
                          userInvalidated: false,
                          iso: false },
                       _isValid: true },
                    updated: 
                     { [Number: 1400807532690]
                       _isAMomentObject: true,
                       _i: Thu May 22 2014 21:12:12 GMT-0400 (Eastern Daylight Time),
                       _isUTC: false,
                       _locale: 
                        { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                          ordinal: [Function],
                          _abbr: &#39;en&#39;,
                          _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                       _d: Thu May 22 2014 21:12:12 GMT-0400 (Eastern Daylight Time),
                       _z: null },
                    comments: true,
                    photos: [],
                    link: &#39;&#39;,
                    _id: &#39;cie5tlwcj000q1wryaipfngca&#39;,
                    content: &#39;&lt;p&gt;This isn’t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24”; this .inf file fixes two common problems:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Users cannot select the native 1920x1200 resolution&lt;/li&gt;\n&lt;li&gt;Games fail with a “Signal out of range” error&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Like many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a &lt;a href=&quot;http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408&quot;&gt;Soyo Topaz S 24” widescreen monitor&lt;/a&gt;… nice.&lt;/p&gt;\n&lt;p&gt;However, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo’s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.&lt;/p&gt;\n&lt;p&gt;A lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows’ restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn’t support.&lt;/p&gt;\n&lt;p&gt;I was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous “Signal out of range” monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor’s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)&lt;/p&gt;\n&lt;p&gt;So, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor… since they weren’t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.&lt;/p&gt;\n&lt;p&gt;I decided to release this little utility for free &lt;a href=&quot;https://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=283420&quot;&gt;on SourceForge&lt;/a&gt;. This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I’ve only thoroughly tested it on Vista x64.&lt;/p&gt;\n&lt;p&gt;To install it, just right-click on the “Generic Non-PnP Monitor” in the Device Manager, update the drivers, and select the inf file.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼1--&amp;gt;/assets/Step+1.png&quot;&gt;&lt;img src=&quot;!--￼0--&amp;gt;/assets/Step+1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Right-click the “Generic Non-PnP Monitor” and select “Update Driver Software…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼3--&amp;gt;/assets/Step+2.png&quot;&gt;&lt;img src=&quot;!--￼2--&amp;gt;/assets/Step+2.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Browse my computer for driver software”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼5--&amp;gt;/assets/Step+3.png&quot;&gt;&lt;img src=&quot;!--￼4--&amp;gt;/assets/Step+3.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Let me pick from a list of device drivers on my computer”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼7--&amp;gt;/assets/Step+4.png&quot;&gt;&lt;img src=&quot;!--￼6--&amp;gt;/assets/Step+4.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Have Disk…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼9--&amp;gt;/assets/Step+5.png&quot;&gt;&lt;img src=&quot;!--￼8--&amp;gt;/assets/Step+5.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Browse…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼11--&amp;gt;/assets/Step+6.png&quot;&gt;&lt;img src=&quot;!--￼10--&amp;gt;/assets/Step+6.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Select the Soyo.inf that was downloaded from SourceForge.net&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼13--&amp;gt;/assets/Step+7.png&quot;&gt;&lt;img src=&quot;!--￼12--&amp;gt;/assets/Step+7.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Next”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼15--&amp;gt;/assets/Step+8.png&quot;&gt;&lt;img src=&quot;!--￼14--&amp;gt;/assets/Step+8.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Confirm security question&lt;/p&gt;\n&lt;p&gt;Enjoy!&lt;/p&gt;\n&#39;,
                    excerpt: &#39;&#39;,
                    more: &#39;&lt;p&gt;This isn’t exactly a programming-related post, but I had a problem that kept bugging me, so I finally decided to sit down and fix it today. I ended up writing a monitor .inf file for the Soyo Topaz 24”; this .inf file fixes two common problems:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;Users cannot select the native 1920x1200 resolution&lt;/li&gt;\n&lt;li&gt;Games fail with a “Signal out of range” error&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;Like many other people, I got in on the nice OfficeMax Black Friday sale about a year ago, scooping up (among other things) a &lt;a href=&quot;http://www.soyo.com/product/LCD_Monitors/9/TOPAZ_S_-_24%26quot%3B_Wide_TFT_LCD_Monitor/408&quot;&gt;Soyo Topaz S 24” widescreen monitor&lt;/a&gt;… nice.&lt;/p&gt;\n&lt;p&gt;However, like many other people, I had problems with Windows recognizing the natural display resolution of 1920x1200. It turns out that this monitor does not correctly report its supported resolutions; furthermore, Soyo’s tech support leaves quite a bit to be desired - they have yet to admit that there is a problem.&lt;/p&gt;\n&lt;p&gt;A lot of folks simply returned their monitors, but I went the route of a few others, disabling Windows’ restrictions on resolutions. One obvious problem with this approach is that if you select a wrong resolution you can actually damage the hardware (at least, I know this used to be true, and the warning is still in the Windows dialog box). You just have to be careful not to select resolutions or refresh rates your monitor doesn’t support.&lt;/p&gt;\n&lt;p&gt;I was happily using my monitor in this fashion until today, when I tried to install a DirectX game. Like many other games, it automatically attempted to raise the refresh rate - not realizing that the monitor is an LCD and not CRT. This resulted in the infamous “Signal out of range” monitor message. In fact, no matter what I tried, this would happen, because even restricting to the monitor’s supported resolutions did not restrict the frame rate (bad, Soyo, bad!)&lt;/p&gt;\n&lt;p&gt;So, I decided to whip out the Soyo manual and make a custom monitor .inf file for my Soyo monitor… since they weren’t going to do it. It took a bit more tinkering and time than I expected, but at the end of the day I was the proud owner of a monitor .inf file for the Soyo Topaz DYLM24D6.&lt;/p&gt;\n&lt;p&gt;I decided to release this little utility for free &lt;a href=&quot;https://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=283420&quot;&gt;on SourceForge&lt;/a&gt;. This should work for every commonly-used Windows system (2000, XP, 2003, Vista, 2008 / x86, x64, IA-64), although I’ve only thoroughly tested it on Vista x64.&lt;/p&gt;\n&lt;p&gt;To install it, just right-click on the “Generic Non-PnP Monitor” in the Device Manager, update the drivers, and select the inf file.&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼1--&amp;gt;/assets/Step+1.png&quot;&gt;&lt;img src=&quot;!--￼0--&amp;gt;/assets/Step+1.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Right-click the “Generic Non-PnP Monitor” and select “Update Driver Software…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼3--&amp;gt;/assets/Step+2.png&quot;&gt;&lt;img src=&quot;!--￼2--&amp;gt;/assets/Step+2.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Browse my computer for driver software”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼5--&amp;gt;/assets/Step+3.png&quot;&gt;&lt;img src=&quot;!--￼4--&amp;gt;/assets/Step+3.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Choose “Let me pick from a list of device drivers on my computer”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼7--&amp;gt;/assets/Step+4.png&quot;&gt;&lt;img src=&quot;!--￼6--&amp;gt;/assets/Step+4.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Have Disk…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼9--&amp;gt;/assets/Step+5.png&quot;&gt;&lt;img src=&quot;!--￼8--&amp;gt;/assets/Step+5.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Browse…”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼11--&amp;gt;/assets/Step+6.png&quot;&gt;&lt;img src=&quot;!--￼10--&amp;gt;/assets/Step+6.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Select the Soyo.inf that was downloaded from SourceForge.net&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼13--&amp;gt;/assets/Step+7.png&quot;&gt;&lt;img src=&quot;!--￼12--&amp;gt;/assets/Step+7.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Click “Next”&lt;/p&gt;\n&lt;p&gt;&lt;a href=&quot;!--￼15--&amp;gt;/assets/Step+8.png&quot;&gt;&lt;img src=&quot;!--￼14--&amp;gt;/assets/Step+8.png&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Confirm security question&lt;/p&gt;\n&lt;p&gt;Enjoy!&lt;/p&gt;\n&#39;,
                    path: [Getter],
                    permalink: [Getter],
                    full_source: [Getter],
                    asset_dir: [Getter],
                    tags: [Getter],
                    categories: [Getter],
                    prev: [Circular],
                    next: 
                     { layout: &#39;post&#39;,
                       title: &#39;Free IOCTL Decoder&#39;,
                       _content: &#39;Unexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.\n\nBecause of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.\n\nOur IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).\n\nWe have decided to release this useful utility for free to the driver development community. It can be downloaded from \n[SourceForge](http://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=279739)\n\nHope you find it useful!\n\n&#39;,
                       source: &#39;_posts/2008-07-03-free-ioctl-decoder.md&#39;,
                       raw: &#39;---\nlayout: post\ntitle: &quot;Free IOCTL Decoder&quot;\n---\nUnexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.\n\nBecause of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.\n\nOur IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).\n\nWe have decided to release this useful utility for free to the driver development community. It can be downloaded from \n[SourceForge](http://sourceforge.net/project/showfiles.php?group_id=213700&amp;package_id=279739)\n\nHope you find it useful!\n\n&#39;,
                       slug: &#39;free-ioctl-decoder&#39;,
                       published: true,
                       date: 
                        { [Number: 1215057600000]
                          _isAMomentObject: true,
                          _i: Thu Jul 03 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                          _isUTC: false,
                          _locale: 
                           { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                             ordinal: [Function],
                             _abbr: &#39;en&#39;,
                             _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                          _d: Thu Jul 03 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                          _z: null,
                          _pf: 
                           { empty: false,
                             unusedTokens: [],
                             unusedInput: [],
                             overflow: -2,
                             charsLeftOver: 0,
                             nullInput: false,
                             invalidMonth: null,
                             invalidFormat: false,
                             userInvalidated: false,
                             iso: false },
                          _isValid: true },
                       updated: 
                        { [Number: 1400776290455]
                          _isAMomentObject: true,
                          _i: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                          _isUTC: false,
                          _locale: 
                           { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                             ordinal: [Function],
                             _abbr: &#39;en&#39;,
                             _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                          _d: Thu May 22 2014 12:31:30 GMT-0400 (Eastern Daylight Time),
                          _z: null },
                       comments: true,
                       photos: [],
                       link: &#39;&#39;,
                       _id: &#39;cie5tluw400021wryxy5yy127&#39;,
                       content: &#39;&lt;p&gt;Unexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.&lt;/p&gt;\n&lt;p&gt;Because of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.&lt;/p&gt;\n&lt;p&gt;Our IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).&lt;/p&gt;\n&lt;p&gt;We have decided to release this useful utility for free to the driver development community. It can be downloaded from&lt;br&gt;&lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=279739&quot;&gt;SourceForge&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Hope you find it useful!&lt;/p&gt;\n&#39;,
                       excerpt: &#39;&#39;,
                       more: &#39;&lt;p&gt;Unexpected IOCTL codes are something that every first-time driver writer must become accustomed to. Sometimes it can be difficult to find out the meaning of a particular IOCTL, since the driver sees it as just a number but the documentation requires a symbolic name and the header files use macros to define it. Often searching for just the number turns up no results, even on the WWW.&lt;/p&gt;\n&lt;p&gt;Because of this common problem, we at Nito Programs have developed a small command-line utility to help decode IOCTLs. Unlike other IOCTL decoders, this utility does not just break down the number into fields; it actually contains a database of known IOCTLs defined by Microsoft. Since this utility has this information available, it supports searching by symbolic name as well as numerical value. Of course, if the IOCTL is not in the database, then the utility will break it down into fields just like other IOCTL decoders.&lt;/p&gt;\n&lt;p&gt;Our IOCTL decoder also supports regular expression string matching, symbolic device name matching (useful for listing all IOCTLs for a particular device), and fuzzy matching (for those few IOCTLs that are defined with the wrong method/access type).&lt;/p&gt;\n&lt;p&gt;We have decided to release this useful utility for free to the driver development community. It can be downloaded from&lt;br&gt;&lt;a href=&quot;http://sourceforge.net/project/showfiles.php?group_id=213700&amp;amp;package_id=279739&quot;&gt;SourceForge&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;Hope you find it useful!&lt;/p&gt;\n&#39;,
                       path: [Getter],
                       permalink: [Getter],
                       full_source: [Getter],
                       asset_dir: [Getter],
                       tags: [Getter],
                       categories: [Getter],
                       prev: [Circular],
                       next: 
                        { layout: &#39;post&#39;,
                          title: &#39;Dynamically loading 32-bit or 64-bit code from a platform-agnostic executable&#39;,
                          _content: &#39;Have you ever had a `BadImageFormatException`? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine...\n\nMost Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++\&#39;s IJW) that was recently updated to support x64 and IA64 as well as x86.\n\nThe main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll\&#39;s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?\n\nWell, after spending a lot of time researching ways it wouldn\&#39;t work (`&lt;probing&gt;`, `GetSystemInfo`, `AppendPrivatePath`), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly\&#39;s `ModuleResolve` event.\n\n`IntPtr.Size` gives you a hint on how to proceed, and from there, `ModuleResolveEventHandler` just needs a bit of `try`...`catch` to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really _is_ missing).\n\n&#39;,
                          source: &#39;_posts/2008-06-20-interop-on-64-bit-platforms.md&#39;,
                          raw: &#39;---\nlayout: post\ntitle: &quot;Dynamically loading 32-bit or 64-bit code from a platform-agnostic executable&quot;\n---\nHave you ever had a `BadImageFormatException`? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine...\n\nMost Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++\&#39;s IJW) that was recently updated to support x64 and IA64 as well as x86.\n\nThe main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll\&#39;s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?\n\nWell, after spending a lot of time researching ways it wouldn\&#39;t work (`&lt;probing&gt;`, `GetSystemInfo`, `AppendPrivatePath`), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly\&#39;s `ModuleResolve` event.\n\n`IntPtr.Size` gives you a hint on how to proceed, and from there, `ModuleResolveEventHandler` just needs a bit of `try`...`catch` to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really _is_ missing).\n\n&#39;,
                          slug: &#39;interop-on-64-bit-platforms&#39;,
                          published: true,
                          date: 
                           { [Number: 1213934400000]
                             _isAMomentObject: true,
                             _i: Fri Jun 20 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                             _isUTC: false,
                             _locale: 
                              { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                ordinal: [Function],
                                _abbr: &#39;en&#39;,
                                _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                             _d: Fri Jun 20 2008 00:00:00 GMT-0400 (Eastern Daylight Time),
                             _z: null,
                             _pf: 
                              { empty: false,
                                unusedTokens: [],
                                unusedInput: [],
                                overflow: -2,
                                charsLeftOver: 0,
                                nullInput: false,
                                invalidMonth: null,
                                invalidFormat: false,
                                userInvalidated: false,
                                iso: false },
                             _isValid: true },
                          updated: 
                           { [Number: 1401196204882]
                             _isAMomentObject: true,
                             _i: Tue May 27 2014 09:10:04 GMT-0400 (Eastern Daylight Time),
                             _isUTC: false,
                             _locale: 
                              { _ordinalParse: /\d{1,2}(th|st|nd|rd)/,
                                ordinal: [Function],
                                _abbr: &#39;en&#39;,
                                _ordinalParseLenient: /\d{1,2}(th|st|nd|rd)|\d{1,2}/ },
                             _d: Tue May 27 2014 09:10:04 GMT-0400 (Eastern Daylight Time),
                             _z: null },
                          comments: true,
                          photos: [],
                          link: &#39;&#39;,
                          _id: &#39;cie5tkbb500011wry3x8f9hsb&#39;,
                          content: &#39;&lt;p&gt;Have you ever had a &lt;code&gt;BadImageFormatException&lt;/code&gt;? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine…&lt;/p&gt;\n&lt;p&gt;Most Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++’s IJW) that was recently updated to support x64 and IA64 as well as x86.&lt;/p&gt;\n&lt;p&gt;The main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll’s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?&lt;/p&gt;\n&lt;p&gt;Well, after spending a lot of time researching ways it wouldn’t work (&lt;code&gt;&amp;lt;probing&amp;gt;&lt;/code&gt;, &lt;code&gt;GetSystemInfo&lt;/code&gt;, &lt;code&gt;AppendPrivatePath&lt;/code&gt;), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly’s &lt;code&gt;ModuleResolve&lt;/code&gt; event.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;IntPtr.Size&lt;/code&gt; gives you a hint on how to proceed, and from there, &lt;code&gt;ModuleResolveEventHandler&lt;/code&gt; just needs a bit of &lt;code&gt;try&lt;/code&gt;…&lt;code&gt;catch&lt;/code&gt; to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really &lt;em&gt;is&lt;/em&gt; missing).&lt;/p&gt;\n&#39;,
                          excerpt: &#39;&#39;,
                          more: &#39;&lt;p&gt;Have you ever had a &lt;code&gt;BadImageFormatException&lt;/code&gt;? It can happen if your platform-agnostic .NET code attempts to load your old x86 dll on a new x64 machine…&lt;/p&gt;\n&lt;p&gt;Most Microsoft native code dlls support x86, x64, and IA64 architectures. We have an interop dll for one of these (using managed C++’s IJW) that was recently updated to support x64 and IA64 as well as x86.&lt;/p&gt;\n&lt;p&gt;The main executable for this project is C#, platform-agnostic, and we wanted to keep it that way. Normally, the installer would just install the exe and then choose one of the interop dll’s to install, based on the architecture. However, we had to create a demo system that could be run without installing - so, the question became: how does one detect the platform at runtime and bind to the appropriate dll?&lt;/p&gt;\n&lt;p&gt;Well, after spending a lot of time researching ways it wouldn’t work (&lt;code&gt;&amp;lt;probing&amp;gt;&lt;/code&gt;, &lt;code&gt;GetSystemInfo&lt;/code&gt;, &lt;code&gt;AppendPrivatePath&lt;/code&gt;), and rejecting setting up a second AppDomain (too much pain and overhead for one simple problem), we finally hit upon a ridiculously simple solution: handle the assembly’s &lt;code&gt;ModuleResolve&lt;/code&gt; event.&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;IntPtr.Size&lt;/code&gt; gives you a hint on how to proceed, and from there, &lt;code&gt;ModuleResolveEventHandler&lt;/code&gt; just needs a bit of &lt;code&gt;try&lt;/code&gt;…&lt;code&gt;catch&lt;/code&gt; to distinguish x64 from IA64. You just have to be careful to handle re-entry situations (in case the dll really &lt;em&gt;is&lt;/em&gt; missing).&lt;/p&gt;\n&#39;,
                          path: [Getter],
                          permalink: [Getter],
                          full_source: [Getter],
                          asset_dir: [Getter],
                          tags: [Getter],
                          categories: [Getter],
                          prev: [Circular] } } } } } } } },
  lang: null,
  canonical_path: &#39;2009/04/24/asynchronous-callback-contexts/index.html&#39; }
</body>
</html>